/* -*- Mode:c++; eval:(c-set-style "BSD"); c-basic-offset:4; indent-tabs-mode:nil; tab-width:8 -*- */

%{

#include <string>
#include <iostream>
#include <sstream>
#include "../tokenizer.h"
#include "../parser.h"

extern int yylex( void );
extern void yyerror( const std::string e );
extern int yylineno; // autogenerated by flex

#define YYDEBUG 1

using namespace std;

static SchemaDef * schema_def = NULL;

static void validate_schema(SchemaDef *sd);

%}

%union
{
    std::string * word;
    WordList    * words;
    TableDef    * table;
    FieldDef    * field;
    TypeDefValue* type;
    FieldAttrs  * attrs;
    int64_t       number_int;
    double        number_double;
    CustomGetUpdList * getupdlist;
    int line_no;
}

%token L_CURLY R_CURLY L_PAREN R_PAREN KW_TABLE KW_OPTIONS
%token KW_INT KW_INT64 KW_TEXT KW_BLOB KW_DOUBLE KW_ENUM
%token KW_INDEX KW_QUERY KW_LIKEQUERY KW_WORD KW_BOOL
%token KW_CUSTOM_GET KW_CUSTOM_UPD KW_CUSTOM_UPDBY KW_CUSTOM_DEL
%token KW_DEFAULT KW_PROTOID KW_PACKAGE KW_VERSION KW_SUBTABLE
%token KW_FOREIGN KW_CUSTOM_SELECT KW_CONSTRAINT KW_AUTOINCR

%token KW_PROTOTOP  KW_PROTOBOTTOM
%token KW_HEADERTOP KW_HEADERBOTTOM
%token KW_SOURCETOP KW_SOURCEBOTTOM
%token KW_CLOSEBLOCK

%token TOK_INTEGER TOK_DOUBLE TOK_STRING TOK_NL TOK_EQ

%type <word>    KW_WORD BLOCKBODY
%type <table>   TABLE
%type <field>   FIELDS FIELD
%type <type>    DATATYPE TYPELIST
%type <attrs>   ATTRIBUTES
%type <number_int> TOK_INTEGER
%type <number_double> TOK_DOUBLE;
%type <word>    TOK_STRING
%type <words>   WORDLIST
%type <getupdlist> CUSTOMGET CUSTOMUPD CUSTOMUPDBY CUSTOMDEL CUSTOMS
%type <line_no>    KW_PROTOTOP  KW_PROTOBOTTOM
%type <line_no>    KW_HEADERTOP KW_HEADERBOTTOM
%type <line_no>    KW_SOURCETOP KW_SOURCEBOTTOM
%type <word>    CONSTRAINT CONSTRAINTS

%start SCHEMA_FILE

%%

SCHEMA_FILE
	: /*nothing*/
	| PACKAGE SCHEMA_FILE
	| OPTIONS SCHEMA_FILE
	| TABLE SCHEMA_FILE
	| BLOCK SCHEMA_FILE
	| CUSTOM_SELECT SCHEMA_FILE
	;

BLOCK
	: KW_PROTOTOP     BLOCKBODY KW_CLOSEBLOCK
        {
            std::ostringstream os;
            os << "// NOTE this is PROTOTOP from line " << $1
               << " of \"" << schema_def->fname << "\"\n";
            schema_def->prototop = os.str() + *$2;
            delete $2;
        }
	| KW_PROTOBOTTOM  BLOCKBODY KW_CLOSEBLOCK
        {
            std::ostringstream os;
            os << "// NOTE this is PROTOBOTTOM from line " << $1
               << " of \"" << schema_def->fname << "\"\n";
            schema_def->protobottom = os.str() + *$2;
            delete $2;
        }
	| KW_SOURCETOP    BLOCKBODY KW_CLOSEBLOCK
        {
            std::ostringstream os;
            os << "#line " << $1 << " \"" << schema_def->fname << "\"\n";
            schema_def->sourcetop = os.str() + *$2;
            delete $2;
        }
	| KW_SOURCEBOTTOM BLOCKBODY KW_CLOSEBLOCK
        {
            std::ostringstream os;
            os << "#line " << $1 << " \"" << schema_def->fname << "\"\n";
            schema_def->sourcebottom = os.str() + *$2;
            delete $2;
        }
	| KW_HEADERTOP    BLOCKBODY KW_CLOSEBLOCK
        {
            std::ostringstream os;
            os << "#line " << $1 << " \"" << schema_def->fname << "\"\n";
            schema_def->headertop = os.str() + *$2;
            delete $2;
        }
	| KW_HEADERBOTTOM BLOCKBODY KW_CLOSEBLOCK
        {
            std::ostringstream os;
            os << "#line " << $1 << " \"" << schema_def->fname << "\"\n";
            schema_def->headerbottom = os.str() + *$2;
            delete $2;
        }
	;

BLOCKBODY
	: /* nothing */
	{
	    $$ = new std::string;
	}
	| TOK_STRING BLOCKBODY
	{
            $1->append(*$2);
	    delete $2;
	    $$ = $1;
	}
	| TOK_NL BLOCKBODY
	{
	    $2->insert(0,"\n");
	    $$ = $2;
	}
	;

PACKAGE
	: KW_PACKAGE TOK_STRING
	{
            schema_def->package = *$2;
            delete $2;
	}
        ;

OPTIONS
	: KW_OPTIONS L_PAREN WORDLIST R_PAREN
	{
            WordList * w = $3, * ww;
            for (ww = w; ww; ww = ww->next)
            {
                if (ww->word == "protobuf")
                    schema_def->option_protobuf = true;
                else if (ww->word == "xml")
                    schema_def->option_xml = true;
                else
                {
                    cerr << "ERROR: OPTIONS '" << ww->word
                         << "' is not known\n";
                    exit(1);
                }
            }
            delete w;
	}
	;

CUSTOM_SELECT
	: KW_CUSTOM_SELECT KW_WORD
	  L_PAREN WORDLIST R_PAREN
	  L_PAREN WORDLIST R_PAREN
	  L_PAREN TYPELIST R_PAREN TOK_STRING
        {
            CustomSelect * csel = new CustomSelect;
            csel->name = *$2;
            delete $2;
            csel->field_names = $4;
            csel->table_names = $7;
            csel->types = $10;
            csel->where_clause = *$12;
            // csel->full_statement not populated.
            delete $12;
            schema_def->add_custom_select(csel);
	}
	| KW_CUSTOM_SELECT KW_WORD
	  L_PAREN WORDLIST R_PAREN
	  L_PAREN TYPELIST R_PAREN
	  TOK_STRING
	{
            CustomSelect * csel = new CustomSelect;
            csel->name = *$2;
            delete $2;
            csel->field_names = $4;
            // csel->table_names not populated.
            csel->types = $7;
            // csel->where_clause not populated.
            csel->full_statement = *$9;
            delete $9;
            schema_def->add_custom_select(csel);
	}
	;

TABLE
	: KW_TABLE KW_WORD KW_VERSION TOK_INTEGER
          L_CURLY FIELDS CONSTRAINTS CUSTOMS R_CURLY
	{
		$$ = new TableDef(*$2);
                $$->version = $4;
                $$->fields = $6;
                if ($7)
                    $$->constraints = ", " + *$7;
                delete $7;
                $$->customs = $8;
		delete $2;
                schema_def->add_table($$);
	}
	;

CONSTRAINTS
	: /*nothing*/
	{
            $$ = NULL;
	}
	| CONSTRAINT CONSTRAINTS
	{
            if ($2)
            {
                *$1 += " ";
                *$1 += *$2;
                delete $2;
            }
            $$ = $1;
	}
	;

CONSTRAINT
	: KW_CONSTRAINT TOK_STRING
	{
            $$ = new string("CONSTRAINT ");
            *$$ += *$2;
            delete $2;
	}
	;

FIELDS
	: FIELD
	{
		$$ = $1;
	}
	| FIELD FIELDS
	{
		$1->next = $2;
		$$ = $1;
	}
	;

FIELD
	: KW_WORD DATATYPE ATTRIBUTES
	{
		$$ = new FieldDef(*$1, *$2);
		$$->attrs = *$3;
                delete $3;
                delete $2;
		delete $1;
	}
	| KW_SUBTABLE KW_WORD KW_PROTOID TOK_INTEGER
	{
		TypeDefValue tdv;
		tdv.init(TYPE_SUBTABLE);
		$$ = new FieldDef(*$2, tdv);
		$$->attrs.subtable = true;
		$$->attrs.protoid = $4;
                if ($4 == 1)
                {
                    fprintf(stderr, "ERROR: PROTOID 1 is reserved for "
                            "schema_version, please start numbering at 2\n");
                    exit(1);
                }
		delete $2;
	}
	;

CUSTOMS
	: /*nothing*/
	{
            $$ = NULL;
	}
	| CUSTOMGET CUSTOMS
	{
            $$ = $1;
            $$->next = $2;
	}
	| CUSTOMUPD CUSTOMS
	{
            $$ = $1;
            $$->next = $2;
	}
	| CUSTOMUPDBY CUSTOMS
	{
            $$ = $1;
            $$->next = $2;
	}
	| CUSTOMDEL CUSTOMS
	{
            $$ = $1;
            $$->next = $2;
	}
	;

CUSTOMGET
	: KW_CUSTOM_GET KW_WORD L_PAREN TYPELIST R_PAREN TOK_STRING
	{
            $$ = new CustomGetUpdList;
            $$->init_get(*$2, $4, *$6);
            delete $2;
            delete $6;
	}
	;

CUSTOMDEL
	: KW_CUSTOM_DEL KW_WORD L_PAREN TYPELIST R_PAREN TOK_STRING
	{
            $$ = new CustomGetUpdList;
            $$->init_del(*$2, $4, *$6);
            delete $2;
            delete $6;
	}
	;

TYPELIST
	: /*nothing*/
	{
            $$ = NULL;
	}
	| DATATYPE TYPELIST
	{
            $$ = $1;
            $$->next = $2;
	}
	;

CUSTOMUPD
	: KW_CUSTOM_UPD KW_WORD L_PAREN WORDLIST R_PAREN
	{
            $$ = new CustomGetUpdList;
            $$->init_upd(*$2, $4);
            delete $2;
	}
	;

CUSTOMUPDBY
	: KW_CUSTOM_UPDBY KW_WORD L_PAREN WORDLIST R_PAREN
          L_PAREN TYPELIST R_PAREN TOK_STRING
	{
            $$ = new CustomGetUpdList;
            $$->init_updby(*$2, $4, $7, *$9);
            delete $2;
            delete $9;
	}
	;

WORDLIST
	: /*nothing*/
	{
            $$ = NULL;
	}
	| KW_WORD WORDLIST
	{
            $$ = new WordList;
            $$->init(*$1);
            $$->next = $2;
            delete $1;
	}
	;

DATATYPE
	: KW_INT
        {
            $$ = new TypeDefValue;
            $$->init(TYPE_INT);
        }
	| KW_INT64
        {
            $$ = new TypeDefValue;
            $$->init(TYPE_INT64);
        }
	| KW_TEXT
        {
            $$ = new TypeDefValue;
            $$->init(TYPE_TEXT);
        }
	| KW_DOUBLE
        {
            $$ = new TypeDefValue;
            $$->init(TYPE_DOUBLE);
        }
	| KW_BLOB
        {
            $$ = new TypeDefValue;
            $$->init(TYPE_BLOB);
        }
	| KW_BOOL
        {
            $$ = new TypeDefValue;
            $$->init(TYPE_BOOL);
        }
	| KW_ENUM KW_WORD
        {
            if (schema_def->option_protobuf == false)
            {
                cerr << "ERROR: cannot use ENUM if "
                     << "\"OPTIONS (protobuf)\" not set\n";
                exit(1);
            }
            $$ = new TypeDefValue;
            $$->init(TYPE_ENUM);
            $$->enum_name = *$2;
            delete $2;
        }
	;

ATTRIBUTES
	: /*nothing*/
	{
		$$ = new FieldAttrs();
	}
	| ATTRIBUTES KW_INDEX
	{
		$$ = $1;
		$$->index = true;
	}
	| ATTRIBUTES KW_QUERY
	{
		$$ = $1;
		$$->query = true;
	}
	| ATTRIBUTES KW_LIKEQUERY
	{
		$$ = $1;
		$$->likequery = true;
	}
	| ATTRIBUTES KW_AUTOINCR
	{
		$$ = $1;
		$$->auto_increment = true;
	}
	| ATTRIBUTES KW_FOREIGN KW_WORD
	{
		// note $3 is "table.field"
		$$ = $1;
		$$->foreign = true;
		size_t dotpos = $3->find_first_of('.');
		if (dotpos != string::npos)
		{
			$$->foreign_table = $3->substr(0,dotpos);
			$$->foreign_field = $3->substr(dotpos+1);
		}
		delete $3;
	}
	| ATTRIBUTES KW_DEFAULT TOK_STRING
	{
		$$ = $1;
		$$->init_string = *$3;
                delete $3;
	}
	| ATTRIBUTES KW_DEFAULT KW_WORD
	{
		$$ = $1;
		$$->init_string = *$3;
                delete $3;
	}
	| ATTRIBUTES KW_DEFAULT TOK_INTEGER
	{
		$$ = $1;
                $$->init_int = $3;
                // if the user makes a 'double' column type
                // but enters a number without a decimal point,
                // it could come in here as an int. to handle
                // that situation, also fill out the double field.
                $$->init_double = (double) $3;
	}
	| ATTRIBUTES KW_DEFAULT TOK_DOUBLE
	{
		$$ = $1;
                $$->init_double = $3;
	}
	| ATTRIBUTES KW_PROTOID TOK_INTEGER
	{
		$$ = $1;
                $$->protoid = $3;
                if ($3 == 1)
                {
                    fprintf(stderr, "ERROR: PROTOID 1 is reserved for "
                            "schema_version, please start numbering at 2\n");
                    exit(1);
                }
                if (schema_def->option_protobuf == false)
                {
                    cerr << "WARNING: PROTOID ignored if "
                         << "\"OPTIONS (protobuf)\" not set\n";
                }
	}
	| ATTRIBUTES TOK_STRING
	{
            $$ = $1;
            $$->constraints = *$2;
            delete $2;
	}
	;

%%

void
yyerror( const string e )
{
    fprintf(stderr, "error: %d: %s\n", yylineno, e.c_str());
    exit( 1 );
}

SchemaDef *
parse_file(const std::string &fname)
{
    FILE * f = fopen(fname.c_str(), "r");
    if (f == NULL)
    {
        fprintf(stderr, "cannot open file '%s'\n", fname.c_str());
        return NULL;
    }
    schema_def = new SchemaDef;
    schema_def->fname = fname;
    tokenizer_init(f);
    yyparse();
    fclose(f);
    validate_schema(schema_def);
    return schema_def;
}

void
print_tokenized_file(const std::string &fname)
{
    FILE * f = fopen(fname.c_str(), "r");
    if (f == NULL)
    {
        fprintf(stderr, "cannot open file '%s'\n", fname.c_str());
        return;
    }
    tokenizer_init(f);
    while (1)
    {
        int c = yylex();

        cout << "got " << c
	     << " ("
	     << (c <= YYMAXUTOK ? yytname[yytranslate[c]] : "")
             << ")";
        if (c == KW_WORD || c == TOK_STRING)
            cout << " \"" << *yylval.word << "\"";
        cout << endl;
        if (c <= 0)
            break;
    }
    fclose(f);
}

std::string
get_type(const TypeDefValue &type)
{
    switch (type.type)
    {
    case TYPE_INT:    return "int";
    case TYPE_INT64:  return "int64";
    case TYPE_TEXT:   return "text";
    case TYPE_BLOB:   return "blob";
    case TYPE_DOUBLE: return "double";
    case TYPE_BOOL:   return "bool";
    case TYPE_ENUM:   return type.enum_name;
    case TYPE_SUBTABLE:  return "SQL_TABLE";
    }
    return "UNKNOWN";
}
void
print_field(FieldDef *fd)
{
    printf("  field %s", fd->name.c_str());
    if (!fd->attrs.subtable)
    {
        printf(" i %d q %d lq %d type %s",
               fd->attrs.index, fd->attrs.query,
               fd->attrs.likequery, get_type(fd->type).c_str());
        if (fd->attrs.foreign)
            printf(" foreign_key %s.%s", fd->attrs.foreign_table.c_str(),
                   fd->attrs.foreign_field.c_str());
    }
    else
    {
        // subtable
        printf(" subtable");
    }
    printf("\n");
}

void
print_table(TableDef *td)
{
    printf("TABLE %s version %d %s\n", td->name.c_str(), td->version,
           td->is_subtable ? "is_subtable" : "");
    FieldDef * fd = td->fields;
    while (fd)
    {
        print_field(fd);
        fd = fd->next;
    }
    CustomGetUpdList * cust = NULL;
    for (cust = td->customs; cust; cust = cust->next)
    {
        if (cust->type == CustomGetUpdList::GET)
        {
            printf("custom GET : get_by_%s (", cust->name.c_str());
            TypeDefValue * type;
            for (type = cust->typelist; type; type = type->next)
            {
                printf("%s", get_type(*type).c_str());
                if (type->next)
                    printf(", ");
            }
            printf(") (\"%s\")\n", cust->query.c_str());
        }
        else
        {
            printf("custom UPD : update_%s (", cust->name.c_str());
            WordList * word;
            for (word = cust->wordlist; word; word = word->next)
            {
                printf("%s", word->word.c_str());
                if (word->next)
                    printf(", ");
            }
            printf(")\n");
        }
    }
}

static TableDef *
is_table(SchemaDef *schema, const std::string &table)
{
    TableDef *tb;
    for (tb = schema->tables; tb; tb = tb->next)
        if (tb->name == table)
            return tb;
    return NULL;
}

static FieldDef *
is_field(TableDef *tb, const std::string &name)
{
    FieldDef * f;
    for (f = tb->fields; f; f = f->next)
        if (name == f->name)
            return f;
    return NULL;
}

static void
validate_table(TableDef *tb)
{
    CustomGetUpdList * cust;
    bool has_autoincr = false;

    // validate the 'words' in any CUSTOM-UPD are
    // actually column names from the table.
    for (cust = tb->customs; cust; cust = cust->next)
    {
        if (cust->type == CustomGetUpdList::UPD ||
            cust->type == CustomGetUpdList::UPDBY)
        {
            WordList * w;
            const char * by =
                (cust->type == CustomGetUpdList::UPD) ? "" : "BY";
            for (w = cust->wordlist; w; w = w->next)
            {
                if (is_field(tb, w->word) == NULL)
                {
                    fprintf(stderr, "ERROR: column '%s' in CUSTOM-UPD%s "
                            "'%s' is not a known column in table '%s'\n",
                            w->word.c_str(), by,
                            cust->name.c_str(), tb->name.c_str());
                    exit(1);
                }
            }
        }
    }

    FieldDef * fd;
    for (fd = tb->fields; fd; fd = fd->next)
    {
        if (fd->type.type == TYPE_ENUM)
        {
            if (fd->attrs.init_string == "")
            {
                fprintf(stderr, "ERROR: DEFAULT required for ENUM type\n");
                exit(1);
            }
        }
        if (fd->attrs.auto_increment)
        {
            if (fd->type.type != TYPE_INT)
            {
                fprintf(stderr, "ERROR: AUTOINCR is only allowed "
                        "on INT type\n");
                exit(1);
            }
            if (has_autoincr)
            {
                fprintf(stderr, "ERROR: AUTOINCR is only allowed "
                        "once in a table\n");
                exit(1);
            }
            has_autoincr = true;
        }
    }
}

static void
validate_schema(SchemaDef *sd)
{
    for (TableDef *tb = sd->tables; tb; tb = tb->next)
    {
        validate_table(tb);

        // validate foreign keys actually exist
        // validate SUBTABLE refers to actual table and field names
        for (FieldDef *fd = tb->fields; fd; fd = fd->next)
        {
            if (fd->attrs.foreign)
            {
                TableDef *tb2 = is_table(sd, fd->attrs.foreign_table);
                if (tb2 == NULL)
                {
                    fprintf(stderr, "ERROR: unknown table '%s' in FOREIGN "
                            "within table '%s' field '%s'\n",
                            fd->attrs.foreign_table.c_str(),
                            tb->name.c_str(), fd->name.c_str());
                    exit(1);
                }
                // now find field
                FieldDef *fd2;
                for (fd2 = tb2->fields; fd2; fd2 = fd2->next)
                    if (fd2->name == fd->attrs.foreign_field)
                        break;
                if (fd2 == NULL)
                {
                    fprintf(stderr, "ERROR: unknown field '%s' in "
                            "table '%s' in FOREIGN in "
                            "table '%s' field '%s'\n",
                            fd->attrs.foreign_field.c_str(),
                            tb2->name.c_str(),
                            tb->name.c_str(),
                            fd->name.c_str());
                    exit(1);
                }
            }
            if (fd->attrs.subtable)
            {
                // fd->name should be a table
                TableDef *tb2 = is_table(sd, fd->name);
                if (tb2 == NULL)
                {
                    fprintf(stderr, "ERROR: SUBTABLE field name '%s' "
                            "should be the same as the name of a table\n",
                            fd->name.c_str());
                    exit(1);
                }
                fd->attrs.subtable_table = tb2;

                // the other table better have a foreign key
                // from this table.
                FieldDef *fd2;
                for (fd2 = tb2->fields; fd2; fd2 = fd2->next)
                {
                    if (fd2->attrs.foreign &&
                        fd2->attrs.foreign_table == tb->name)
                    {
                        break;
                    }
                }
                if (fd2 == NULL)
                {
                    fprintf(stderr, "ERROR: SUBTABLE '%s' has no FOREIGN "
                            "key from this table '%s'\n",
                            fd->name.c_str(), tb->name.c_str());
                    exit(1);
                }
                fd->attrs.subtable_field = fd2;
                if (fd2->attrs.query == false)
                {
                    fprintf(stderr, "ERROR: FOREIGN key '%s.%s' must have "
                            "QUERY in order to use SUBTABLE in table '%s'\n",
                            tb2->name.c_str(), fd2->name.c_str(),
                            tb->name.c_str());
                    exit(1);
                }

                tb2->is_subtable = true;
            }
        }
    }

    CustomSelect * csel;
    for (csel = sd->custom_selects; csel; csel = csel->next)
    {
        // validate field_names are actually valid "table.field"
        WordList * wl;
        for (wl = csel->field_names; wl; wl = wl->next)
        {
            size_t dotpos = wl->word.find_first_of('.');
            if (dotpos == string::npos)
            {
                fprintf(stderr, "ERROR: CUSTOM-SELECT '%s' fields should be "
                        "of the form 'table.field'\n", csel->name.c_str());
                exit(1);
            }
            string table = wl->word.substr(0,dotpos);
            string field = wl->word.substr(dotpos+1);
            TableDef * tb = is_table(sd, table);
            if (tb == NULL)
            {
                fprintf(stderr, "ERROR: CUSTOM-SELECT '%s' field table '%s' "
                        "is not a table\n",
                        csel->name.c_str(), table.c_str());
                exit(1);
            }
            csel->field_table_ptrs.push_back(tb);
            FieldDef * f = NULL;
            if (field != "rowid")
            {
                f = is_field(tb, field);
                if (f == NULL)
                {
                    fprintf(stderr, "ERROR: CUSTOM-SELECT '%s' field '%s' "
                            "is not a field in table '%s'\n",
                            csel->name.c_str(),
                            wl->word.c_str(), table.c_str());
                    exit(1);
                }
            }
            // it's ok we're pushing a NULL in the case
            // of a rowid: it's by design.
            csel->field_ptrs.push_back(f);
        }
        // validate number of "?" in where-clause
        // matches number of types
        int question_count = 0;
        if (csel->table_names == NULL)
        {
            // CUSTOM-SELECT full-statement case.
            if (csel->full_statement.size() == 0)
            {
                fprintf(stderr, "ERROR: CUSTOM-SELECT full-statement is empty\n");
                exit(1);
            }
            for (size_t pos = 0; pos < csel->full_statement.size(); pos++)
                if (csel->full_statement[pos] == '?')
                    question_count++;
        }
        else
        {
            // validate table_names are valid tables
            for (wl = csel->table_names; wl; wl = wl->next)
            {
                TableDef * tb = is_table(sd, wl->word);
                if (tb == NULL)
                {
                    fprintf(stderr, "ERROR: CUSTOM-SELECT '%s' table '%s' "
                            "is not a table\n",
                            csel->name.c_str(), wl->word.c_str());
                    exit(1);
                }
                csel->table_ptrs.push_back(tb);
            }
            for (size_t pos = 0; pos < csel->where_clause.size(); pos++)
                if (csel->where_clause[pos] == '?')
                    question_count++;
        }
        int types_count = 0;
        for (TypeDefValue *tdv = csel->types; tdv; tdv = tdv->next)
            types_count++;
        printf("question count = %d types count = %d\n",
               question_count, types_count);
        if (question_count != types_count)
        {
            fprintf(stderr, "ERROR: CUSTOM-SELECT '%s' count of "
                    "arg types (%d) does not match count of unknowns "
                    "in WHERE clause (%d)\n", csel->name.c_str(),
                    types_count, question_count);
            exit(1);
        }
    }
}

static void
print_custom_select(CustomSelect * csel)
{
    printf("custom select %s(", csel->name.c_str());
    TypeDefValue *type = csel->types;
    int count = 1;
    while (type)
    {
        printf("%s v%d", get_type(*type).c_str(), count++);
        if (type->next)
            printf(", ");
        type = type->next;
    }
    printf("): SELECT ");
    WordList * wl = csel->field_names;
    while (wl)
    {
        printf("%s", wl->word.c_str());
        if (wl->next)
            printf(", ");
        wl = wl->next;
    }
    printf(" FROM ");
    wl = csel->table_names;
    while (wl)
    {
        printf("%s", wl->word.c_str());
        if (wl->next)
            printf(", ");
        wl = wl->next;
    }
    printf(" WHERE %s\n", csel->where_clause.c_str());
}

void
print_schema(SchemaDef * schema)
{
    TableDef *tds = schema->tables;
    while (tds)
    {
        print_table(tds);
        tds = tds->next;
    }

    CustomSelect * csel = schema->custom_selects;
    while (csel)
    {
        print_custom_select(csel);
        csel = csel->next;
    }
}
