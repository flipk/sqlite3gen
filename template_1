/* -*- Mode:c++; eval:(c-set-style "BSD"); c-basic-offset:4; indent-tabs-mode:nil; tab-width:8 -*- */

________ HEADER_TOP

///////////////////////////////////////////////////////////
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
//                                                       //
//       THIS FILE IS AUTOGENERATED BY sqlite3gen        //
// DO NOT EDIT THIS FILE, EDIT THE SOURCE AND REGENERATE //
//                                                       //
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
///////////////////////////////////////////////////////////

#include <inttypes.h>
#include <string>
#include "sqlite3.h"
@@protobuf_header@@

@@headertop_block@@

namespace @@package@@ {

typedef void (*sql_log_function_t)(void *arg, sqlite3_stmt *);
typedef void (*table_version_callback)(
    sqlite3 *pdb,
    const std::string &table_name,
    int version_in_file,
    int version_in_code);

________ END

________ TABLE_CLASS_DEFN

class SQL_TABLE_@@tablename@@ {
    sqlite3_stmt * pStmt_insert;
    sqlite3_stmt * pStmt_update;
    sqlite3_stmt * pStmt_delete_rowid;
    sqlite3_stmt * pStmt_get_by_rowid;
    sqlite3_stmt * pStmt_get_all;
@@stmt_by_decls@@
@@stmt_by_decls_like@@
@@stmt_custom_get_decls@@
@@stmt_custom_upd_decls@@
@@stmt_custom_del_decls@@

protected:
    sqlite3 *pdb;
    sqlite3_stmt * previous_get;
    bool get_columns(sqlite3_stmt *pStmt);
    static sql_log_function_t log_upd_func;
    static sql_log_function_t log_get_func;
    static void * log_arg;

public:
    SQL_TABLE_@@tablename@@(sqlite3 *_pdb = NULL);
    virtual ~SQL_TABLE_@@tablename@@(void);

    static const int TABLE_VERSION = @@tableversion@@;

    void init(void);
    void init_statements(void);
    void finalize(void);

    void set_db(sqlite3 *_pdb) {
        finalize();
        pdb = _pdb;
    }

    sqlite3_int64 rowid;

@@table_field_type_name_decls@@
@@table_query_method_protos@@
@@table_query_like_method_protos@@
@@table_custom_get_method_protos@@
    bool get_next(void);
    bool insert(void); // updates rowid
    bool update(void);
    bool delete_rowid(void); // delete by rowid
    bool get_by_rowid(int64_t v1);
    bool get_all(void);
@@table_custom_upd_method_protos@@
@@table_custom_del_method_protos@@
@@table_proto_copy_protos@@

    static void register_log_funcs(sql_log_function_t _upd_func,
                                   sql_log_function_t _get_func,
                                   void *_arg)
    {
        log_upd_func = _upd_func;
        log_get_func = _get_func;
        log_arg  = _arg;
    }
    static bool init(sqlite3 *pdb, table_version_callback cb);
    static bool table_create(sqlite3 *pdb);
    static void table_drop(sqlite3 *pdb);
};

________ END

________ TABLE_CLASS_stmt_by_decl
    sqlite3_stmt * pStmt_by_@@fieldname@@;
________ END

________ TABLE_CLASS_stmt_by_decl_like
    sqlite3_stmt * pStmt_by_@@fieldname@@_like;
________ END

________ TABLE_CLASS_stmt_custom_get_decl
    sqlite3_stmt * pStmt_get_@@customname@@;
________ END

________ TABLE_CLASS_stmt_custom_upd_decl
    sqlite3_stmt * pStmt_update_@@customname@@;
________ END

________ TABLE_CLASS_stmt_custom_updby_decl
    sqlite3_stmt * pStmt_update_by_@@customname@@;
________ END

________ TABLE_CLASS_stmt_custom_del_decl
    sqlite3_stmt * pStmt_del_@@customname@@;
________ END

________ TABLE_CLASS_table_field_type_name_decls
    @@fieldtype@@ @@fieldname@@;
________ END

________ TABLE_CLASS_table_query_method_protos
    bool get_by_@@fieldname@@(@@fieldtype@@ v);
________ END

________ TABLE_CLASS_table_query_method_protos_like
    bool get_by_@@fieldname@@_like(const std::string &patt);
________ END

________ TABLE_CLASS_table_custom_get_method_protos
    bool get_@@customname@@(@@type_and_vX@@);
________ END

________ TABLE_CLASS_table_custom_upd_method_protos
    bool update_@@customname@@(void);
________ END

________ TABLE_CLASS_table_custom_updby_method_protos
    bool update_by_@@customname@@(@@type_and_vX@@);
________ END

________ TABLE_CLASS_table_custom_del_method_protos
    bool delete_@@customname@@(@@type_and_vX@@);
________ END

________ TABLE_CLASS_proto_copy_proto
    void CopyToProto(@@package@@::TABLE_@@tablename@@_m &msg);
    void CopyFromProto(const @@package@@::TABLE_@@tablename@@_m &msg);
________ END

________ CLASS_ALL_TABELS_DEFN

class SQL_TABLE_ALL_TABLES {
public:
    static bool init_all(sqlite3 *pdb, table_version_callback cb);
    static void table_drop_all(sqlite3 *pdb);
};

}; // namespace @@package@@

@@headerbottom_block@@

________ END

________ SOURCE_TOP

///////////////////////////////////////////////////////////
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
//                                                       //
//       THIS FILE IS AUTOGENERATED BY sqlite3gen        //
// DO NOT EDIT THIS FILE, EDIT THE SOURCE AND REGENERATE //
//                                                       //
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
///////////////////////////////////////////////////////////

#include "@@headerfile@@"
#include <string.h>
#include <stdio.h>

@@sourcetop_block@@

namespace @@package@@ {

________ END

________ TABLE_CLASS_IMPL

//static
sql_log_function_t SQL_TABLE_@@tablename@@ :: log_upd_func = NULL;
sql_log_function_t SQL_TABLE_@@tablename@@ :: log_get_func = NULL;
void *             SQL_TABLE_@@tablename@@ :: log_arg  = NULL;

SQL_TABLE_@@tablename@@ :: SQL_TABLE_@@tablename@@(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
}

void
SQL_TABLE_@@tablename@@ :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

@@prepare_queries@@
@@prepare_like_queries@@
@@prepare_custom_get_queries@@
@@prepare_custom_upd@@
@@prepare_custom_del@@

    previous_get = NULL;
    init();
}

SQL_TABLE_@@tablename@@ :: ~SQL_TABLE_@@tablename@@(void)
{
    finalize();
}

void
SQL_TABLE_@@tablename@@ :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

@@finalize_queries@@
@@finalize_like_queries@@
@@finalize_custom_get_queries@@
@@finalize_custom_upd@@
@@finalize_custom_del@@

    init_statements();
}

void SQL_TABLE_@@tablename@@ :: init(void)
{
    rowid = -1;
@@initial_values@@
    previous_get = NULL;
}

bool SQL_TABLE_@@tablename@@ :: get_columns(sqlite3_stmt * pStmt)
{
    int got;

    rowid = sqlite3_column_int64(pStmt, 0);

@@get_columns@@

    return true;
}

@@query_implementations@@
@@query_like_implementations@@

bool SQL_TABLE_@@tablename@@ :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_@@tablename@@ :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        printf("ERROR: attempt INSERT before set_db\n");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO @@tablename@@ "
            "(@@fieldnames@@) "
            "values (@@questionmarks@@)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building INSERT at line %d\n", __LINE__);
    }
    sqlite3_reset(pStmt_insert);

@@insert_binders@@

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: insert: r = %d\n", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_@@tablename@@ :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        printf("ERROR: attempt UPDATE before set_db\n");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE @@tablename@@ SET "
            "(@@fieldnames@@) "
            "= (@@questionmarks@@) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building UPDATE at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update);

@@update_binders@@

    r = sqlite3_bind_int64(pStmt_update,
                           @@column_index@@, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: update: r = %d\n", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_@@tablename@@ :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        printf("ERROR: attempt DELETE before set_db\n");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM @@tablename@@ WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building UPDATE at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: "
                "delete_rowid: r = %d\n", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_@@tablename@@ :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        printf("ERROR: attempt GET before set_db\n");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@ WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for "
                   "get_by_rowid at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_@@tablename@@  :: get_by_rowid "
                ": bind: r = %d\n", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_@@tablename@@ :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        printf("ERROR: attempt GET before set_db\n");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for "
                   "get_all at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

@@custom_get_implementations@@
@@custom_upd_implementations@@
@@custom_del_implementations@@
@@table_proto_copy_funcs@@

//static
bool SQL_TABLE_@@tablename@@ :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"@@tablename@@\"",
        -1, &s, NULL);
    sqlite3_reset(s);
    int r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"@@tablename@@\",@@tableversion@@)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "@@tablename@@", v, @@tableversion@@);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (@@tableversion@@) "
            "WHERE name = \"@@tablename@@\"",
            NULL, NULL, NULL);
    }
    else
    {
        printf("ERROR r = %d\n", r);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_@@tablename@@ :: table_create(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        printf("ERROR: attempt CREATE with null db\n");
        return false;
    }

    sqlite3_exec(pdb, "CREATE TABLE @@tablename@@ "
        "(@@table_create_fields@@)",
        NULL, NULL, NULL);

    printf("CREATE TABLE: CREATE TABLE @@tablename@@ "
           "(@@table_create_fields@@)\n");

@@index_creation@@

    return true;
}

//static
void SQL_TABLE_@@tablename@@ :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        printf("ERROR: attempt DROP with null db\n");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE @@tablename@@",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        printf("DROP TABLE @@tablename@@ ERROR: %s\n", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE @@tablename@@\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}

________ END

________ TABLE_prepare_query
    pStmt_by_@@fieldname@@ = NULL;
________ END

________ TABLE_prepare_like_query
    pStmt_by_@@fieldname@@_like = NULL;
________ END

________ TABLE_prepare_custom_get_query
    pStmt_get_@@customname@@ = NULL;
________ END

________ TABLE_prepare_custom_upd
    pStmt_update_@@customname@@ = NULL;
________ END

________ TABLE_prepare_custom_updby
    pStmt_update_by_@@customname@@ = NULL;
________ END

________ TABLE_prepare_custom_del
    pStmt_del_@@customname@@ = NULL;
________ END

________ TABLE_finalize_query
    if (pStmt_by_@@fieldname@@)
        sqlite3_finalize(pStmt_by_@@fieldname@@);
________ END

________ TABLE_finalize_like_query
    if (pStmt_by_@@fieldname@@_like)
        sqlite3_finalize(pStmt_by_@@fieldname@@_like);
________ END

________ TABLE_finalize_custom_get_query
    if (pStmt_get_@@customname@@)
        sqlite3_finalize(pStmt_get_@@customname@@);
________ END

________ TABLE_finalize_custom_upd
    if (pStmt_update_@@customname@@)
        sqlite3_finalize(pStmt_update_@@customname@@);
________ END

________ TABLE_finalize_custom_updby
    if (pStmt_update_by_@@customname@@)
        sqlite3_finalize(pStmt_update_by_@@customname@@);
________ END

________ TABLE_finalize_custom_del
    if (pStmt_del_@@customname@@)
        sqlite3_finalize(pStmt_del_@@customname@@);
________ END

________ TABLE_get_column_pod
    got = sqlite3_column_type(pStmt, @@column_index@@);
    if (got != SQLITE_@@sqlite_type@@)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: get_columns "
                "(@@fieldname@@) : "
                "column @@column_index@@ wrong type (%d %d)\n",
                got, SQLITE_@@sqlite_type@@);
        return false;
    }
    @@fieldname@@ = @@sqlite_column_func@@(pStmt, @@column_index@@);
________ END

________ TABLE_get_column_enum
    got = sqlite3_column_type(pStmt, @@column_index@@);
    if (got != SQLITE_@@sqlite_type@@)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: get_columns "
                "(@@fieldname@@) : "
                "column @@column_index@@ wrong type (%d %d)\n",
                got, SQLITE_@@sqlite_type@@);
        return false;
    }
    if (@@fieldtype@@_IsValid(@@fieldname@@))
        @@fieldname@@ = (@@fieldtype@@) @@sqlite_column_func@@(
            pStmt, @@column_index@@);
    else
    @@initial_value@@
________ END

________ TABLE_get_column_bool
    got = sqlite3_column_type(pStmt, @@column_index@@);
    if (got != SQLITE_@@sqlite_type@@)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: get_columns "
                "(@@fieldname@@) : "
                "column @@column_index@@ wrong type (%d %d)\n",
                got, SQLITE_@@sqlite_type@@);
        return false;
    }
    if (@@sqlite_column_func@@(pStmt, @@column_index@@))
        @@fieldname@@ = true;
    else
        @@fieldname@@ = false;
________ END

________ TABLE_get_column_string
    got = sqlite3_column_type(pStmt, @@column_index@@);
    if (got != SQLITE_@@sqlite_type@@)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: get_columns "
                "(@@fieldname@@) : "
                "column @@column_index@@ wrong type (%d %d)\n",
                got, SQLITE_@@sqlite_type@@);
        return false;
    }
    {
        const void * ptr = @@sqlite_column_func@@(
            pStmt, @@column_index@@);
        int len = sqlite3_column_bytes(pStmt, @@column_index@@);
        @@fieldname@@.resize(len);
        memcpy((void*)@@fieldname@@.c_str(), ptr, len);
    }
________ END

________ TABLE_query_implementation
bool SQL_TABLE_@@tablename@@ :: get_by_@@fieldname@@(@@fieldtype@@ v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        printf("ERROR: attempt GET before set_db\n");
        return false;
    }

    if (pStmt_by_@@fieldname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@ WHERE @@fieldname@@ = ?",
            -1, &pStmt_by_@@fieldname@@, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for @@fieldname@@ at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_@@fieldname@@);

@@query_bind@@

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_@@fieldname@@);

    r = sqlite3_step(pStmt_by_@@fieldname@@);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_@@fieldname@@);
        previous_get = pStmt_by_@@fieldname@@;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
________ END

________ TABLE_query_bind_pod
    r = @@sqlite_bind_func@@(pStmt_by_@@fieldname@@, 1, v);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: get_by_@@fieldname@@ "
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_query_bind_bool
    r = @@sqlite_bind_func@@(pStmt_by_@@fieldname@@, 1,
                             v ? 1 : 0);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: get_by_@@fieldname@@ "
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_query_bind_string
    r = @@sqlite_bind_func@@(pStmt_by_@@fieldname@@, 1,
         v.c_str(), v.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: get_by_@@fieldname@@ "
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_query_like_implementation
bool SQL_TABLE_@@tablename@@ :: get_by_@@fieldname@@_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        printf("ERROR: attempt GET before set_db\n");
        return false;
    }

    if(pStmt_by_@@fieldname@@_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@ WHERE @@fieldname@@ like ?",
            -1, &pStmt_by_@@fieldname@@_like, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT LIKE for @@fieldname@@ at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_@@fieldname@@_like);

    r = @@sqlite_bind_func@@(pStmt_by_@@fieldname@@_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: "
                "get_by_@@fieldname@@_like : bind: r = %d\n", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_@@fieldname@@_like);

    r = sqlite3_step(pStmt_by_@@fieldname@@_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_@@fieldname@@_like);
        previous_get = pStmt_by_@@fieldname@@_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
________ END

________ TABLE_insert_binder_pod
    r = @@sqlite_bind_func@@(pStmt_@@stmt@@, @@column_index@@,
                             @@fieldname@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: @@stmt@@: "
                "bind @@fieldname@@: r = %d\n", r);
    }
________ END

________ TABLE_insert_binder_bool
    r = @@sqlite_bind_func@@(pStmt_@@stmt@@, @@column_index@@,
                             @@fieldname@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: @@stmt@@: "
                "bind @@fieldname@@: r = %d\n", r);
    }
________ END

________ TABLE_insert_binder_enum
    r = @@sqlite_bind_func@@(pStmt_@@stmt@@, @@column_index@@,
                             (int) @@fieldname@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: @@stmt@@: "
                "bind @@fieldname@@: r = %d\n", r);
    }
________ END

________ TABLE_insert_binder_string
    r = @@sqlite_bind_func@@(pStmt_@@stmt@@, @@column_index@@,
         @@fieldname@@.c_str(), @@fieldname@@.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: @@stmt@@: "
                "bind @@fieldname@@: r = %d\n", r);
    }
________ END

________ TABLE_custom_get_implementation
bool SQL_TABLE_@@tablename@@ :: get_@@customname@@(@@type_and_vX@@)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        printf("ERROR: attempt GET before set_db\n");
        return false;
    }

    if(pStmt_get_@@customname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@ "
            "WHERE @@querystring@@",
            -1, &pStmt_get_@@customname@@, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for "
                   "CUSTOM-GET @@customname@@ at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_get_@@customname@@);

@@custom_get_binders@@

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_@@customname@@);

    r = sqlite3_step(pStmt_get_@@customname@@);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_@@customname@@);
        previous_get = pStmt_get_@@customname@@;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
________ END

________ TABLE_custom_get_binder_pod
    r = @@sqlite_bind_func@@(pStmt_get_@@customname@@,
                             @@arg_index@@, v@@arg_index@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, 
                "SQL_TABLE_@@tablename@@ :: get_@@customname@@ "\
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_get_binder_bool
    r = @@sqlite_bind_func@@(pStmt_get_@@customname@@,
                             @@arg_index@@, v@@arg_index@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, 
                "SQL_TABLE_@@tablename@@ :: get_@@customname@@ "\
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_get_binder_enum
    r = @@sqlite_bind_func@@(pStmt_get_@@customname@@,
                             @@arg_index@@, (int) v@@arg_index@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, 
                "SQL_TABLE_@@tablename@@ :: get_@@customname@@ "\
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_get_binder_string
    r = @@sqlite_bind_func@@(pStmt_get_@@customname@@, @@arg_index@@, 
                          v@@arg_index@@.c_str(), v@@arg_index@@.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, 
                "SQL_TABLE_@@tablename@@ :: get_@@customname@@ : "
                "bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_upd_implementation
bool SQL_TABLE_@@tablename@@ :: update_@@customname@@(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        printf("ERROR: attempt UPDATE before set_db\n");
        return false;
    }

    if(pStmt_update_@@customname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE @@tablename@@ SET (@@custom_fieldlist@@) = "
            "(@@custom_questionmarks@@) WHERE rowid = ?",
            -1, &pStmt_update_@@customname@@, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building CUSTOM-UPD "
                   "@@customname@@ at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update_@@customname@@);

@@custom_update_binders@@

    r = sqlite3_bind_int64(pStmt_update_@@customname@@,
                           @@fieldindex@@, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_@@customname@@);

    r = sqlite3_step(pStmt_update_@@customname@@);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: update "
                "@@customname@@: r = %d\n", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
________ END

________ TABLE_custom_updby_implementation
bool SQL_TABLE_@@tablename@@ :: update_by_@@customname@@(@@type_and_vX@@)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        printf("ERROR: attempt UPDATE before set_db\n");
        return false;
    }

    if(pStmt_update_by_@@customname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE @@tablename@@ SET (@@custom_fieldlist@@) = "
            "(@@custom_questionmarks@@) WHERE @@querystring@@",
            -1, &pStmt_update_by_@@customname@@, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building CUSTOM-UPDBY "
                   "@@customname@@ at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update_by_@@customname@@);

@@custom_update_binders@@

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_by_@@customname@@);

    r = sqlite3_step(pStmt_update_by_@@customname@@);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: update "
                "@@customname@@: r = %d\n", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
________ END

________ TABLE_custom_upd_binder_pod
    r = @@sqlite_bind_func@@(pStmt_@@by@@_@@customname@@,
                             @@fieldindex@@, @@fieldname@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: "
             "@@by@@_@@customname@@: bind @@fieldname@@: r = %d\n", r);
    }
________ END

________ TABLE_custom_upd_binder_bool
    r = @@sqlite_bind_func@@(pStmt_@@by@@_@@customname@@,
                             @@fieldindex@@, @@fieldname@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: "
            "@@by@@_@@customname@@: bind @@fieldname@@: r = %d\n", r);
    }
________ END

________ TABLE_custom_upd_binder_enum
    r = @@sqlite_bind_func@@(pStmt_@@by@@_@@customname@@,
                             @@fieldindex@@, (int) @@fieldname@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: "
            "@@by@@_@@customname@@: bind @@fieldname@@: r = %d\n", r);
    }
________ END

________ TABLE_custom_upd_binder_string
    r = @@sqlite_bind_func@@(
        pStmt_@@by@@_@@customname@@, @@fieldindex@@,
         @@fieldname@@.c_str(), @@fieldname@@.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_@@tablename@@ :: "
            "@@by@@_@@customname@@: bind @@fieldname@@: r = %d\n", r);
    }
________ END

________ TABLE_custom_updby_binder_pod
    r = @@sqlite_bind_func@@(pStmt_update_by_@@customname@@,
                             @@arg_index@@, v@@fieldindex@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_@@tablename@@ :: update_by_@@customname@@ "\
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_updby_binder_bool
    r = @@sqlite_bind_func@@(pStmt_update_by_@@customname@@,
                             @@arg_index@@, v@@fieldindex@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_@@tablename@@ :: update_by_@@customname@@ "\
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_updby_binder_enum
    r = @@sqlite_bind_func@@(pStmt_update_by_@@customname@@,
                             @@arg_index@@, (int) v@@fieldindex@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_@@tablename@@ :: update_by_@@customname@@ "\
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_updby_binder_string
    r = @@sqlite_bind_func@@(pStmt_update_by_@@customname@@, @@arg_index@@,
                          v@@fieldindex@@.c_str(), v@@fieldindex@@.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_@@tablename@@ :: update_by_@@customname@@ : "
                "bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_del_implementation
bool SQL_TABLE_@@tablename@@ :: delete_@@customname@@(@@type_and_vX@@)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        printf("ERROR: attempt DELETE before set_db\n");
        return false;
    }

    if(pStmt_del_@@customname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "DELETE FROM @@tablename@@ WHERE @@querystring@@",
            -1, &pStmt_del_@@customname@@, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building DELETE for "
                   "CUSTOM-DEL @@customname@@ at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_del_@@customname@@);

@@custom_del_binders@@

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_del_@@customname@@);

    r = sqlite3_step(pStmt_del_@@customname@@);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_del_@@customname@@);
        previous_get = pStmt_del_@@customname@@;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
________ END

________ TABLE_custom_del_binder_pod
    r = @@sqlite_bind_func@@(pStmt_del_@@customname@@,
                             @@arg_index@@, v@@arg_index@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_@@tablename@@ :: delete_@@customname@@ "\
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_del_binder_bool
    r = @@sqlite_bind_func@@(pStmt_del_@@customname@@,
                             @@arg_index@@, v@@arg_index@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_@@tablename@@ :: delete_@@customname@@ "\
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_del_binder_enum
    r = @@sqlite_bind_func@@(pStmt_del_@@customname@@,
                             @@arg_index@@, (int) v@@arg_index@@);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_@@tablename@@ :: delete_@@customname@@ "\
                ": bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_custom_del_binder_string
    r = @@sqlite_bind_func@@(pStmt_del_@@customname@@, @@arg_index@@,
                          v@@arg_index@@.c_str(), v@@arg_index@@.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_@@tablename@@ :: delete_@@customname@@ : "
                "bind: r = %d\n", r);
        return false;
    }
________ END

________ TABLE_proto_copy_funcs
void
SQL_TABLE_@@tablename@@ :: CopyToProto(
              @@package@@::TABLE_@@tablename@@_m &msg)
{
@@proto_copy_to@@
}

void
SQL_TABLE_@@tablename@@ :: CopyFromProto(
              const @@package@@::TABLE_@@tablename@@_m &msg)
{
@@proto_copy_from@@
}
________ END

________ TABLE_proto_copy_to_field
    msg.set_@@fieldname_lower@@(@@fieldname@@);
________ END

________ TABLE_proto_copy_to_field_bool
    msg.set_@@fieldname_lower@@(@@fieldname@@ ? true : false);
________ END

________ TABLE_proto_copy_to_field_enum
    if (!@@fieldtype@@_IsValid(@@fieldname@@))
    @@initial_value@@
    msg.set_@@fieldname_lower@@(@@fieldname@@);
________ END

________ TABLE_proto_copy_from_field
    if (msg.has_@@fieldname_lower@@())
        @@fieldname@@ = msg.@@fieldname_lower@@();
    else
    @@initial_value@@
________ END

________ TABLE_proto_copy_from_field_bool
    if (msg.has_@@fieldname_lower@@())
        @@fieldname@@ = msg.@@fieldname_lower@@() ? true : false;
    else
    @@initial_value@@
________ END

________ TABLE_create_index
    sqlite3_exec(pdb,"CREATE INDEX @@tablename@@_@@fieldname@@ "
                 "ON @@tablename@@ (@@fieldname@@)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX @@tablename@@_@@fieldname@@ "
           "ON @@tablename@@ (@@fieldname@@)\n");
________ END

________ CLASS_ALL_TABELS_IMPL

bool SQL_TABLE_ALL_TABLES :: init_all(sqlite3 *pdb, table_version_callback cb)
{
    sqlite3_stmt * s;
    sqlite3_prepare_v2(pdb,
        "select * from sqlite_master "
        "where name = \"tables\" and type = \"table\"",
        -1, &s, NULL);
    sqlite3_reset(s);
    int r = sqlite3_step(s);
    if (r == SQLITE_DONE)
    {
        // the table does NOT exist, create it
        sqlite3_exec(pdb,
                     "CREATE TABLE tables (name text, version int)",
                     NULL, NULL, NULL);
    }
    sqlite3_finalize(s);

@@create_all_tables@@

    return true;
}

void SQL_TABLE_ALL_TABLES :: table_drop_all(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        printf("ERROR: attempt DROP with null db\n");
        return;
    }

@@drop_all_tables@@

    sqlite3_exec(pdb,
                 "DROP TABLE tables",
                 NULL, NULL, NULL);
}

}; // namespace @@package@@

@@sourcebottom_block@@

________ END

________ CLASS_ALL_TABLES_create_a_table
    if (!SQL_TABLE_@@tablename@@::init(pdb, cb))
        return false;
________ END

________ CLASS_ALL_TABLES_drop_a_table
    SQL_TABLE_@@tablename@@::table_drop(pdb);
________ END

________ PROTO_TOP

///////////////////////////////////////////////////////////
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
//                                                       //
//       THIS FILE IS AUTOGENERATED BY sqlite3gen        //
// DO NOT EDIT THIS FILE, EDIT THE SOURCE AND REGENERATE //
//                                                       //
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
///////////////////////////////////////////////////////////

syntax = "proto2";

package @@package@@;

@@prototop_block@@

________ END

// note, @@protobottom_block@@ is inserted by the code.

________ PROTO_message

message @@tablename@@_m
{
@@protofields@@
}

________ END

________ PROTO_protofield
  optional @@fieldtype@@ @@fieldname@@ = @@fieldnum@@;
________ END
