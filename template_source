/* -*- Mode:c++; eval:(c-set-style "BSD"); c-basic-offset:4; indent-tabs-mode:nil; tab-width:8 -*- */

________ SOURCE_TOP

///////////////////////////////////////////////////////////
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
//                                                       //
//       THIS FILE IS AUTOGENERATED BY sqlite3gen        //
// DO NOT EDIT THIS FILE, EDIT THE SOURCE AND REGENERATE //
//                                                       //
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
///////////////////////////////////////////////////////////

#include "@@headerfile@@"
#include <string.h>
#include <stdio.h>
#include <sstream>
#include <iostream>

@@sourcetop_block@@

namespace @@package@@ {

static void dflt_log_upd(void *arg, sqlite3_stmt *stmt)
{
    char * sql = sqlite3_expanded_sql(stmt);
    printf("SQL UPDATE: %s\n", sql);
    sqlite3_free(sql);
}

static void dflt_log_get(void *arg, sqlite3_stmt *stmt)
{
    char * sql = sqlite3_expanded_sql(stmt);
    printf("SQL GET: %s\n", sql);
    sqlite3_free(sql);
}

static void dflt_log_err(void *arg, const std::string &msg)
{
    printf("SQL ERROR: %s\n", msg.c_str());
}

static inline char nibble_to_hex(unsigned char nib)
{
    if (nib > 9)
        return nib - 10 + 'a';
    return nib + '0';
}

static void blob_to_hex(std::string &out, const std::string &in)
{
    out.clear();
    for (size_t ind = 0; ind < in.size(); ind++)
    {
        unsigned char c = (unsigned char) in[ind];
        out += nibble_to_hex((c >> 4) & 0xf);
        out += nibble_to_hex((c >> 0) & 0xf);
    }
}

static char hex_to_nibble(char c)
{
    if (c >= '0' && c <= '9')
        return c - '0';
    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    return 0xff;
}

static bool hex_to_blob(std::string &out, const std::string &in)
{
    if ((in.size() % 2) == 1)
        return false;

    out.clear();
    for (size_t ind = 0; ind < in.size(); ind += 2)
    {
        char l = hex_to_nibble(in[ind]);
        char r = hex_to_nibble(in[ind+1]);
        if (l == 0xff || r == 0xff)
            return false;
        char c = (l << 4) + r;
        out += c;
    }

    return true;
}

void _____dummy_blob_spacer(void)
{
    // this func exists only to eliminate 'defined but not used'
    // warnings on the above static funcs.
    std::string a,b;
    hex_to_blob(a,b);
    blob_to_hex(a,b);
}
________ END

________ TABLE_CLASS_IMPL

//static
sql_log_function_t SQL_TABLE_@@tablename@@ :: log_upd_func = &dflt_log_upd;
sql_log_function_t SQL_TABLE_@@tablename@@ :: log_get_func = &dflt_log_get;
void *             SQL_TABLE_@@tablename@@ :: log_arg  = NULL;
sql_err_function_t SQL_TABLE_@@tablename@@ :: err_log_func = &dflt_log_err;
void *             SQL_TABLE_@@tablename@@ :: err_log_arg  = NULL;

SQL_TABLE_@@tablename@@ :: SQL_TABLE_@@tablename@@(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
    xml_decoders_initialized = false;
}

// copy constructor, duplicates all the data fields (including rowid)
// but does not duplicate the statement pointers, because then they'd
// get double-freed.
SQL_TABLE_@@tablename@@ :: SQL_TABLE_@@tablename@@(
    const SQL_TABLE_@@tablename@@ &other)
{
    init_statements();

    pdb = other.pdb;
    rowid = other.rowid;
@@field_copies@@
}

void
SQL_TABLE_@@tablename@@ :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

@@prepare_queries@@
@@prepare_like_queries@@
@@prepare_custom_get_queries@@
@@prepare_custom_upd@@
@@prepare_custom_del@@

    previous_get = NULL;
    init();
}

SQL_TABLE_@@tablename@@ :: ~SQL_TABLE_@@tablename@@(void)
{
    finalize();
}

void
SQL_TABLE_@@tablename@@ :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

@@finalize_queries@@
@@finalize_like_queries@@
@@finalize_custom_get_queries@@
@@finalize_custom_upd@@
@@finalize_custom_del@@

    init_statements();
}

void SQL_TABLE_@@tablename@@ :: init(void)
{
    rowid = -1;
@@initial_values@@
    previous_get = NULL;
}

//static
void
SQL_TABLE_@@tablename@@ :: print_err(const char *function, int lineno,
                                     const char *format, ...)
{
    if (err_log_func == NULL)
        // don't bother formatting the args.
        return;

    std::ostringstream msg_out;
    msg_out << function << ":" << lineno << ": ";
    std::string msg = msg_out.str();

    size_t offset = msg.size();
    msg.resize(offset + 250);

    va_list ap;
    va_start(ap, format);
    size_t l = vsnprintf((char*)msg.c_str() + offset,
                         250, format, ap);
    va_end(ap);
    // note that *snprintf returns what it WOULD have written
    // if there was space! so l > msg.size means it truncated.
    if (l < 250)
        msg.resize(l + offset);
    err_log_func(err_log_arg, msg);
}

#undef  PRINT_ERR
#define PRINT_ERR(args...) print_err(__PRETTY_FUNCTION__, __LINE__, args)

bool SQL_TABLE_@@tablename@@ :: get_columns(sqlite3_stmt * pStmt)
{
    int got;

    rowid = sqlite3_column_int64(pStmt, 0);

@@get_columns@@

    return true;
}

@@query_implementations@@
@@query_like_implementations@@

bool SQL_TABLE_@@tablename@@ :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_@@tablename@@ :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO @@tablename@@ "
            "(@@fieldnames@@) "
            "values (@@questionmarks@@)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing INSERT", r);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

@@insert_binders@@

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("insert: r = %d", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_@@tablename@@ :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE @@tablename@@ SET "
            "(@@fieldnames@@) "
            "= (@@questionmarks@@) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing UPDATE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

@@update_binders@@

    r = sqlite3_bind_int64(pStmt_update,
                           @@column_index@@, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_@@tablename@@ :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM @@tablename@@ WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing DELETE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("delete: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_@@tablename@@ :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@ WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_by_rowid", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_@@tablename@@ :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_all", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

@@get_subtable_implementations@@

void SQL_TABLE_@@tablename@@ :: get_subtables(void)
{
@@get_all_subtables@@
}

void SQL_TABLE_@@tablename@@ :: insert_subtables(void)
{
@@insert_all_subtables@@
}

@@custom_get_implementations@@
@@custom_upd_implementations@@
@@custom_del_implementations@@
@@table_proto_copy_funcs@@
@@table_xml_copy_funcs@@

//static
bool SQL_TABLE_@@tablename@@ :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"@@tablename@@\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("select from tables: %d", r);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"@@tablename@@\",@@tableversion@@)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "@@tablename@@", v, @@tableversion@@);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (@@tableversion@@) "
            "WHERE name = \"@@tablename@@\"",
            NULL, NULL, NULL);
    }
    else
    {
        PRINT_ERR("select from tables / step r = %d", r);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_@@tablename@@ :: table_create(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    sqlite3_exec(pdb, "CREATE TABLE @@tablename@@ "
        "(@@table_create_fields@@)",
        NULL, NULL, NULL);

    printf("CREATE TABLE: CREATE TABLE @@tablename@@ "
           "(@@table_create_fields@@)\n");

@@index_creation@@

    return true;
}

//static
void SQL_TABLE_@@tablename@@ :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE @@tablename@@",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE @@tablename@@\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}

//static
void SQL_TABLE_@@tablename@@ :: export_xml(sqlite3 *pdb,
                                           tinyxml2::XMLElement *el)
{
    SQL_TABLE_@@tablename@@ row(pdb);

    bool ok = row.get_all();
    while (ok)
    {
        row.get_subtables();
        tinyxml2::XMLElement * row_el =
            el->GetDocument()->NewElement("@@tablename@@");
        row.copy_to_xml(row_el);
        el->InsertEndChild(row_el);
        ok = row.get_next();
    }
}

//static
bool SQL_TABLE_@@tablename@@ :: import_xml(sqlite3 *pdb,
                                           tinyxml2::XMLElement *el)
{
    tinyxml2::XMLElement * row_el;
    SQL_TABLE_@@tablename@@  row(pdb);

    for (row_el = el->FirstChildElement(); row_el;
         row_el = row_el->NextSiblingElement())
    {
        row.copy_from_xml(row_el);
        row.insert();
        row.insert_subtables();
    }

    return true;
}

________ END

________ TABLE_prepare_query
    pStmt_by_@@fieldname@@ = NULL;
________ END

________ TABLE_prepare_like_query
    pStmt_by_@@fieldname@@_like = NULL;
________ END

________ TABLE_prepare_custom_get_query
    pStmt_get_@@customname@@ = NULL;
________ END

________ TABLE_prepare_custom_upd
    pStmt_update_@@customname@@ = NULL;
________ END

________ TABLE_prepare_custom_updby
    pStmt_update_by_@@customname@@ = NULL;
________ END

________ TABLE_prepare_custom_del
    pStmt_del_@@customname@@ = NULL;
________ END

________ TABLE_finalize_query
    if (pStmt_by_@@fieldname@@)
        sqlite3_finalize(pStmt_by_@@fieldname@@);
________ END

________ TABLE_finalize_like_query
    if (pStmt_by_@@fieldname@@_like)
        sqlite3_finalize(pStmt_by_@@fieldname@@_like);
________ END

________ TABLE_finalize_custom_get_query
    if (pStmt_get_@@customname@@)
        sqlite3_finalize(pStmt_get_@@customname@@);
________ END

________ TABLE_finalize_custom_upd
    if (pStmt_update_@@customname@@)
        sqlite3_finalize(pStmt_update_@@customname@@);
________ END

________ TABLE_finalize_custom_updby
    if (pStmt_update_by_@@customname@@)
        sqlite3_finalize(pStmt_update_by_@@customname@@);
________ END

________ TABLE_finalize_custom_del
    if (pStmt_del_@@customname@@)
        sqlite3_finalize(pStmt_del_@@customname@@);
________ END

________ TABLE_get_column_pod
    got = sqlite3_column_type(pStmt, @@column_index@@);
    if (got != SQLITE_@@sqlite_type@@)
    {
        PRINT_ERR("get_columns (@@fieldname@@) : "
                "column @@column_index@@ wrong type (%d %d)",
                got, SQLITE_@@sqlite_type@@);
        return false;
    }
    @@fieldname@@ = @@sqlite_column_func@@(pStmt, @@column_index@@);
________ END

________ TABLE_get_column_enum
    got = sqlite3_column_type(pStmt, @@column_index@@);
    if (got != SQLITE_@@sqlite_type@@)
    {
        PRINT_ERR("get_columns (@@fieldname@@) : "
                "column @@column_index@@ wrong type (%d %d)",
                got, SQLITE_@@sqlite_type@@);
        return false;
    }
    if (@@fieldtype@@_IsValid(@@fieldname@@))
        @@fieldname@@ = (@@fieldtype@@) @@sqlite_column_func@@(
            pStmt, @@column_index@@);
    else
    @@initial_value@@
________ END

________ TABLE_get_column_bool
    got = sqlite3_column_type(pStmt, @@column_index@@);
    if (got != SQLITE_@@sqlite_type@@)
    {
        PRINT_ERR("get_columns (@@fieldname@@) : "
                "column @@column_index@@ wrong type (%d %d)",
                got, SQLITE_@@sqlite_type@@);
        return false;
    }
    if (@@sqlite_column_func@@(pStmt, @@column_index@@))
        @@fieldname@@ = true;
    else
        @@fieldname@@ = false;
________ END

________ TABLE_get_column_string
      // SQLITE3 appears to ignore the column type in a CREATE TABLE!
      // NOTE: if you INSERT a string to a table that contains
      //       all decimal digits, SQLITE3 does something very strange:
      //       it stores it as SQLITE_INT! this means this validation
      //       fails. but if you call sqlite_column_text, it will convert
      //       it back to a text string for you.
    got = sqlite3_column_type(pStmt, @@column_index@@);
    if (got != SQLITE_@@sqlite_type@@)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (@@fieldname@@) : "
                "column @@column_index@@ wrong type (%d %d)",
                got, SQLITE_@@sqlite_type@@);
        return false;
#endif
    }
    {
        const void * ptr = @@sqlite_column_func@@(
            pStmt, @@column_index@@);
        int len = sqlite3_column_bytes(pStmt, @@column_index@@);
        @@fieldname@@.resize(len);
        memcpy((void*)@@fieldname@@.c_str(), ptr, len);
    }
________ END

________ TABLE_query_implementation
bool SQL_TABLE_@@tablename@@ :: get_by_@@fieldname@@(@@fieldtype@@ v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_@@fieldname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@ WHERE @@fieldname@@ = ?",
            -1, &pStmt_by_@@fieldname@@, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_@@fieldname@@);

@@query_bind@@

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_@@fieldname@@);

    r = sqlite3_step(pStmt_by_@@fieldname@@);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_@@fieldname@@);
        previous_get = pStmt_by_@@fieldname@@;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
________ END

________ TABLE_query_bind_pod
    r = @@sqlite_bind_func@@(pStmt_by_@@fieldname@@, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }
________ END

________ TABLE_query_bind_bool
    r = @@sqlite_bind_func@@(pStmt_by_@@fieldname@@, 1,
                             v ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }
________ END

________ TABLE_query_bind_string
    r = @@sqlite_bind_func@@(pStmt_by_@@fieldname@@, 1,
         v.c_str(), v.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }
________ END

________ TABLE_query_like_implementation
bool SQL_TABLE_@@tablename@@ :: get_by_@@fieldname@@_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_by_@@fieldname@@_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@ "
            "WHERE @@fieldname@@ like ?",
            -1, &pStmt_by_@@fieldname@@_like, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT LIKE for @@fieldname@@", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_@@fieldname@@_like);

    r = @@sqlite_bind_func@@(pStmt_by_@@fieldname@@_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_@@fieldname@@_like);

    r = sqlite3_step(pStmt_by_@@fieldname@@_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_@@fieldname@@_like);
        previous_get = pStmt_by_@@fieldname@@_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
________ END

________ TABLE_insert_binder_pod
    r = @@sqlite_bind_func@@(pStmt_@@stmt@@, @@column_index@@,
                             @@fieldname@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("@@stmt@@: bind @@fieldname@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_insert_binder_bool
    r = @@sqlite_bind_func@@(pStmt_@@stmt@@, @@column_index@@,
                             @@fieldname@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("@@stmt@@: bind @@fieldname@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_insert_binder_enum
    r = @@sqlite_bind_func@@(pStmt_@@stmt@@, @@column_index@@,
                             (int) @@fieldname@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("@@stmt@@: bind @@fieldname@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_insert_binder_string
    r = @@sqlite_bind_func@@(pStmt_@@stmt@@, @@column_index@@,
         @@fieldname@@.c_str(), @@fieldname@@.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("@@stmt@@: bind @@fieldname@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_get_subtable_implementation
int SQL_TABLE_@@tablename@@ :: get_subtable_@@fieldname@@(void)
{
    SQL_TABLE_@@fieldname@@  row(pdb);
    bool status;
    int count = 0;

    @@fieldname@@.clear();
    status = row.get_by_@@other_key@@(@@this_key@@);
    while (status)
    {
        // note this uses the special table class
        // copy constructor that only copies the data,
        // not the prepared statements.
        @@fieldname@@.push_back(row);
        count++;
        status = row.get_next();
    }

    return count;
}

bool SQL_TABLE_@@tablename@@ :: insert_subtable_@@fieldname@@(void)
{
    for (size_t ind = 0; ind < @@fieldname@@.size(); ind++)
    {
        SQL_TABLE_@@fieldname@@ &row = @@fieldname@@[ind];
        row.insert();
    }
    return true;
}
________ END

________ TABLE_CLASS_get_all_subtables_one
    get_subtable_@@fieldname@@();
________ END

________ TABLE_CLASS_insert_all_subtables_one
    insert_subtable_@@fieldname@@();
________ END

________ TABLE_custom_get_implementation
bool SQL_TABLE_@@tablename@@ :: get_@@customname@@(@@type_and_vX@@)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_@@customname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,@@fieldnames@@ FROM @@tablename@@ "
            "WHERE @@querystring@@",
            -1, &pStmt_get_@@customname@@, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET @@customname@@", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_@@customname@@);

@@custom_get_binders@@

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_@@customname@@);

    r = sqlite3_step(pStmt_get_@@customname@@);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_@@customname@@);
        previous_get = pStmt_get_@@customname@@;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
________ END

________ TABLE_custom_get_binder_pod
    r = @@sqlite_bind_func@@(pStmt_get_@@customname@@,
                             @@arg_index@@, v@@arg_index@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_get_binder_bool
    r = @@sqlite_bind_func@@(pStmt_get_@@customname@@,
                             @@arg_index@@, v@@arg_index@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_get_binder_enum
    r = @@sqlite_bind_func@@(pStmt_get_@@customname@@,
                             @@arg_index@@, (int) v@@arg_index@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_get_binder_string
    r = @@sqlite_bind_func@@(pStmt_get_@@customname@@, @@arg_index@@, 
                          v@@arg_index@@.c_str(), v@@arg_index@@.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_upd_implementation
bool SQL_TABLE_@@tablename@@ :: update_@@customname@@(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_@@customname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE @@tablename@@ SET (@@custom_fieldlist@@) = "
            "(@@custom_questionmarks@@) WHERE rowid = ?",
            -1, &pStmt_update_@@customname@@, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPD "
                   "@@customname@@", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_@@customname@@);

@@custom_update_binders@@

    r = sqlite3_bind_int64(pStmt_update_@@customname@@,
                           @@fieldindex@@, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_@@customname@@);

    r = sqlite3_step(pStmt_update_@@customname@@);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update @@customname@@: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
________ END

________ TABLE_custom_updby_implementation
bool SQL_TABLE_@@tablename@@ :: update_by_@@customname@@(@@type_and_vX@@)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_by_@@customname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE @@tablename@@ SET (@@custom_fieldlist@@) = "
            "(@@custom_questionmarks@@) WHERE @@querystring@@",
            -1, &pStmt_update_by_@@customname@@, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPDBY "
                      "@@customname@@", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_by_@@customname@@);

@@custom_update_binders@@

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_by_@@customname@@);

    r = sqlite3_step(pStmt_update_by_@@customname@@);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update @@customname@@: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
________ END

________ TABLE_custom_upd_binder_pod
    r = @@sqlite_bind_func@@(pStmt_@@by@@_@@customname@@,
                             @@fieldindex@@, @@fieldname@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind @@fieldname@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_upd_binder_bool
    r = @@sqlite_bind_func@@(pStmt_@@by@@_@@customname@@,
                             @@fieldindex@@, @@fieldname@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind @@fieldname@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_upd_binder_enum
    r = @@sqlite_bind_func@@(pStmt_@@by@@_@@customname@@,
                             @@fieldindex@@, (int) @@fieldname@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind @@fieldname@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_upd_binder_string
    r = @@sqlite_bind_func@@(
        pStmt_@@by@@_@@customname@@, @@fieldindex@@,
         @@fieldname@@.c_str(), @@fieldname@@.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind @@fieldname@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_updby_binder_pod
    r = @@sqlite_bind_func@@(pStmt_update_by_@@customname@@,
                             @@arg_index@@, v@@fieldindex@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind field @@fieldindex@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_updby_binder_bool
    r = @@sqlite_bind_func@@(pStmt_update_by_@@customname@@,
                             @@arg_index@@, v@@fieldindex@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind field @@fieldindex@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_updby_binder_enum
    r = @@sqlite_bind_func@@(pStmt_update_by_@@customname@@,
                             @@arg_index@@, (int) v@@fieldindex@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind field @@fieldindex@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_updby_binder_string
    r = @@sqlite_bind_func@@(pStmt_update_by_@@customname@@, @@arg_index@@,
                          v@@fieldindex@@.c_str(), v@@fieldindex@@.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind field @@fieldindex@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_del_implementation
bool SQL_TABLE_@@tablename@@ :: delete_@@customname@@(@@type_and_vX@@)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if(pStmt_del_@@customname@@ == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "DELETE FROM @@tablename@@ WHERE @@querystring@@",
            -1, &pStmt_del_@@customname@@, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-DEL", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_del_@@customname@@);

@@custom_del_binders@@

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_del_@@customname@@);

    r = sqlite3_step(pStmt_del_@@customname@@);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_del_@@customname@@);
        previous_get = pStmt_del_@@customname@@;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
________ END

________ TABLE_custom_del_binder_pod
    r = @@sqlite_bind_func@@(pStmt_del_@@customname@@,
                             @@arg_index@@, v@@arg_index@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind arg @@arg_index@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_del_binder_bool
    r = @@sqlite_bind_func@@(pStmt_del_@@customname@@,
                             @@arg_index@@, v@@arg_index@@ ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind arg @@arg_index@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_del_binder_enum
    r = @@sqlite_bind_func@@(pStmt_del_@@customname@@,
                             @@arg_index@@, (int) v@@arg_index@@);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind arg @@arg_index@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_custom_del_binder_string
    r = @@sqlite_bind_func@@(pStmt_del_@@customname@@, @@arg_index@@,
                          v@@arg_index@@.c_str(), v@@arg_index@@.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind arg @@arg_index@@: r = %d", r);
        return false;
    }
________ END

________ TABLE_proto_copy_funcs
void
SQL_TABLE_@@tablename@@ :: copy_to_proto(
              @@package@@::TABLE_@@tablename@@_m &msg)
{
    msg.set_schema_version(TABLE_VERSION);
@@proto_copy_to@@
}

void
SQL_TABLE_@@tablename@@ :: copy_from_proto(
              const @@package@@::TABLE_@@tablename@@_m &msg)
{
    if (msg.has_schema_version() && msg.schema_version() != TABLE_VERSION)
    {
        // NOTE : if this becomes a problem in the future, we could
        //        enhance sql3gen to allow the user to register a
        //        callback function which can convert a message from
        //        one schema version to another.
        std::ostringstream err;
        err << "SQL_TABLE_@@tablename@@ :: "
            << "copy_from_proto : recvd protobuf message with "
            << "schema version " << msg.schema_version()
            << " (supported is " << TABLE_VERSION
            << ")\n";
        if (err_log_func)
            err_log_func(err_log_arg, err.str());
        else
            std::cerr << err.str();
    }
@@proto_copy_from@@
}
________ END

________ TABLE_proto_copy_to_field
    msg.set_@@fieldname_lower@@(@@fieldname@@);
________ END

________ TABLE_proto_copy_to_field_bool
    msg.set_@@fieldname_lower@@(@@fieldname@@ ? true : false);
________ END

________ TABLE_proto_copy_to_field_enum
    if (!@@fieldtype@@_IsValid(@@fieldname@@))
    @@initial_value@@
    msg.set_@@fieldname_lower@@(@@fieldname@@);
________ END

________ TABLE_proto_copy_from_field
    if (msg.has_@@fieldname_lower@@())
        @@fieldname@@ = msg.@@fieldname_lower@@();
    else
    @@initial_value@@
________ END

________ TABLE_proto_copy_from_field_bool
    if (msg.has_@@fieldname_lower@@())
        @@fieldname@@ = msg.@@fieldname_lower@@() ? true : false;
    else
    @@initial_value@@
________ END

________ TABLE_proto_copy_to_subtable
    msg.clear_@@fieldname@@();
    for (size_t ind = 0; ind < @@fieldname@@.size(); ind++)
        @@fieldname@@[ind].copy_to_proto(*msg.add_@@fieldname@@());
________ END

________ TABLE_proto_copy_from_subtable
    @@fieldname@@.clear();
    @@fieldname@@.resize(msg.@@fieldname@@_size());
    for (int ind = 0; ind < msg.@@fieldname@@_size(); ind++)
    {
        @@fieldname@@[ind].set_db(pdb);
        @@fieldname@@[ind].copy_from_proto(msg.@@fieldname@@(ind));
    }
________ END


________ TABLE_xml_copy_funcs
void
SQL_TABLE_@@tablename@@ :: copy_to_xml(tinyxml2::XMLElement *el)
{
    el->SetValue("@@tablename@@");
    el->SetAttribute("type", "row");
    el->SetAttribute("rowid", (int64_t) rowid);

@@xml_copy_to@@
}

@@xml_decoder_functions@@

bool
SQL_TABLE_@@tablename@@ :: copy_from_xml(const tinyxml2::XMLElement *el)
{
    init();
    if (xml_decoders_initialized == false)
    {
@@xml_decoder_initializers@@
        xml_decoders_initialized = true;
    }
    if (strcmp(el->Value(), "@@tablename@@") != 0)
    {
        if (err_log_func)
        {
            std::ostringstream err;
            err << "SQL_TABLE_@@tablename@@ :: "
                << "copy_from_xml : node name is " << el->Value()
                << " not '@@tablename@@'!\n";
            err_log_func(err_log_arg, err.str().c_str());
        }
        return false;
    }
    const tinyxml2::XMLElement * child = el->FirstChildElement();
    while (child)
    {
        const char * v = child->Value();
        if (v && v[0] != 0)
        {
            xml_decoder_map_t::iterator it = xml_decoders.find(v);
            if (it != xml_decoders.end())
            {
                xml_decoder_func_t f = it->second;
                if ((this->*f)(child) == false)
                    return false;
            }
        }
        child = child->NextSiblingElement();
    }
    return true;
}
________ END

________ TABLE_xml_decoder_initializer
        xml_decoders["@@fieldname@@"] =
            &SQL_TABLE_@@tablename@@::xml_decoder_@@fieldname@@;
________ END

________ TABLE_copy_pod_to_xml
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("@@fieldname@@");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << @@fieldname@@;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }
________ END

________ TABLE_copy_xml_to_pod
bool
SQL_TABLE_@@tablename@@ :: xml_decoder_@@fieldname@@(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> @@fieldname@@;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}
________ END

________ TABLE_copy_string_to_xml
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("@@fieldname@@");
        child->SetAttribute("type", "text");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(@@fieldname@@.c_str());
        child->InsertEndChild(v);
    }
________ END

________ TABLE_copy_xml_to_string
bool
SQL_TABLE_@@tablename@@ :: xml_decoder_@@fieldname@@(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    @@fieldname@@ = "";
    if (n)
    {
        const char * v = n->Value();
        if (v)
            @@fieldname@@ = v;
    }
    return true;
}
________ END

________ TABLE_copy_blob_to_xml
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("@@fieldname@@");
        child->SetAttribute("type", "blob");
        el->InsertEndChild(child);
        std::string hex;
        blob_to_hex(hex, @@fieldname@@);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(hex.c_str());
        child->InsertEndChild(v);
    }
________ END

________ TABLE_copy_xml_to_blob
bool
SQL_TABLE_@@tablename@@ :: xml_decoder_@@fieldname@@(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
            hex_to_blob(@@fieldname@@, v);
        else
            @@fieldname@@ = "";
        return true;
    }
    return false;
}
________ END

________ TABLE_copy_bool_to_xml
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("@@fieldname@@");
        child->SetAttribute("type", "bool");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(@@fieldname@@ ? "true" : "false");
        child->InsertEndChild(v);
    }
________ END

________ TABLE_copy_xml_to_bool
bool
SQL_TABLE_@@tablename@@ :: xml_decoder_@@fieldname@@(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            if (strcmp(v, "true") == 0)
                @@fieldname@@ = true;
            else if (strcmp(v, "false") == 0)
                @@fieldname@@ = false;
            else
                return false;
        }
        return true;
    }
    return false;
}
________ END

________ TABLE_copy_enum_to_xml
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("@@fieldname@@");
        child->SetAttribute("type", "@@fieldtype@@");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(
                @@fieldtype@@_Name(@@fieldname@@).c_str());
        child->InsertEndChild(v);
    }
________ END

________ TABLE_copy_xml_to_enum
bool
SQL_TABLE_@@tablename@@ :: xml_decoder_@@fieldname@@(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
            return @@fieldtype@@_Parse(v, &@@fieldname@@);
        return true;
    }
    return false;
}
________ END

________ TABLE_copy_subtable_to_xml
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("@@fieldname@@");
        child->SetAttribute("type", "subtable");
        el->InsertEndChild(child);
        for (size_t ind = 0; ind < @@fieldname@@.size(); ind++)
        {
            tinyxml2::XMLElement * child2 =
                el->GetDocument()->NewElement("@@fieldname@@");
            child2->SetAttribute("type", "subtable_row");
            child2->SetAttribute("index", (int) ind);
            child->InsertEndChild(child2);
            SQL_TABLE_@@fieldname@@ &f = @@fieldname@@[ind];
            f.copy_to_xml(child2);
        }
    }
________ END

________ TABLE_copy_xml_to_subtable
bool
SQL_TABLE_@@tablename@@ :: xml_decoder_@@fieldname@@(const tinyxml2::XMLElement *el)
{
    SQL_TABLE_@@fieldname@@  row(pdb);

    if (strcmp(el->Value(), "@@fieldname@@") != 0)
        return false;

    const tinyxml2::XMLElement *child = el->FirstChildElement();
    while (child)
    {
        if (row.copy_from_xml(child) == false)
            return false;
        @@fieldname@@.push_back(row);
        child = child->NextSiblingElement();
    }

    return true;
}
________ END

________ TABLE_create_constraints
, FOREIGN KEY(@@fieldname@@) REFERENCES @@foreign_table@@(@@foreign_field@@)
________ ENDNL

________ TABLE_create_index
    sqlite3_exec(pdb,"CREATE INDEX @@tablename@@_@@fieldname@@ "
                 "ON @@tablename@@ (@@fieldname@@)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX @@tablename@@_@@fieldname@@ "
           "ON @@tablename@@ (@@fieldname@@)\n");
________ END

________ CLASS_ALL_TABELS_IMPL

bool SQL_TABLE_ALL_TABLES :: init_all(sqlite3 *pdb, table_version_callback cb)
{
    sqlite3_stmt * s;
    sqlite3_prepare_v2(pdb,
        "select * from sqlite_master "
        "where name = \"tables\" and type = \"table\"",
        -1, &s, NULL);
    sqlite3_reset(s);
    int r = sqlite3_step(s);
    if (r == SQLITE_DONE)
    {
        // the table does NOT exist, create it
        sqlite3_exec(pdb,
                     "CREATE TABLE tables (name text, version int)",
                     NULL, NULL, NULL);
    }
    sqlite3_finalize(s);

@@create_all_tables@@

    return true;
}

void SQL_TABLE_ALL_TABLES :: table_drop_all(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        fprintf(stderr, "attempted DROP (all) with null db\n");
        return;
    }

@@drop_all_tables@@

    sqlite3_exec(pdb,
                 "DROP TABLE tables",
                 NULL, NULL, NULL);
}

void SQL_TABLE_ALL_TABLES :: register_log_funcs(
    sql_log_function_t _upd_func,
    sql_log_function_t _get_func,
    void *_arg,
    sql_err_function_t _err_func,
    void *_err_arg)
{
@@register_all_logfuncs@@
}

//static
void SQL_TABLE_ALL_TABLES :: export_xml_all(sqlite3 *pdb,
                                            tinyxml2::XMLDocument &doc)
{
    doc.InsertEndChild(doc.NewDeclaration());
    tinyxml2::XMLElement * root = doc.NewElement("@@package@@");
    tinyxml2::XMLElement * tab = NULL;
    doc.InsertEndChild(root);
    root->SetAttribute("schema_time", "@@schema_time@@");
    struct tm export_time;
    time_t now = time(NULL);
    localtime_r(&now, &export_time);
    char export_time_str[100];
    strftime(export_time_str, 100, "%Y-%m%d-%H%M%S", &export_time);
    root->SetAttribute("export_time", export_time_str);
@@table_export_all@@
}

//static
bool SQL_TABLE_ALL_TABLES :: import_xml_all(sqlite3 *pdb,
                                            tinyxml2::XMLDocument &doc)
{
    tinyxml2::XMLElement * root = doc.RootElement();
    if (strcmp(root->Value(), "@@package@@") != 0)
    {
        fprintf(stderr, "ERROR: SQL_TABLE_ALL_TABLES :: import_xml_all : "
                "root element '%s' does not match package '%s'\n",
                root->Value(), "@@package@@");
        return false;
    }
    tinyxml2::XMLElement * table;
    for (table = root->FirstChildElement(); table;
         table = table->NextSiblingElement())
    {
        const char * table_name = table->Value();
@@table_import_all@@
    }
    return true;
}

}; // namespace @@package@@

@@sourcebottom_block@@

________ END

________ CLASS_ALL_TABLES_create_a_table
    if (!SQL_TABLE_@@tablename@@::init(pdb, cb))
        return false;
________ END

________ CLASS_ALL_TABLES_drop_a_table
    SQL_TABLE_@@tablename@@::table_drop(pdb);
________ END

________ CLASS_ALL_TABLES_register_a_logfunc
    SQL_TABLE_@@tablename@@::register_log_funcs(
        _upd_func, _get_func, _arg, _err_func, _err_arg);
________ END

________ CLASS_ALL_TABLES_export_a_table
    if (/*is_subtable*/ @@is_subtable@@)
    {
        tinyxml2::XMLComment * c = doc.NewComment(
            "table @@tablename@@ is a subtable of another table");
        root->InsertEndChild(c);
    }
    else
    {
        tab = doc.NewElement("@@tablename@@");
        tab->SetAttribute("type", "table");
        tab->SetAttribute("version", @@tableversion@@);
        SQL_TABLE_@@tablename@@ :: export_xml(pdb, tab);
        root->InsertEndChild(tab);
    }
________ END

________ CLASS_ALL_TABLES_import_a_table
    if (strcmp(table_name, "@@tablename@@") == 0)
    {
        if (SQL_TABLE_@@tablename@@::import_xml(pdb,table) == false)
            return false;
    }
________ END
