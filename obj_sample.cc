
///////////////////////////////////////////////////////////
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
//                                                       //
//       THIS FILE IS AUTOGENERATED BY sqlite3gen        //
// DO NOT EDIT THIS FILE, EDIT THE SOURCE AND REGENERATE //
//                                                       //
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
///////////////////////////////////////////////////////////

#include "sample.h"
#include <string.h>
#include <stdio.h>
#include <sstream>
#include <iostream>


/* source top line 1 */
/* source top line 2 */


namespace library {

static void dflt_log_upd(void *arg, sqlite3_stmt *stmt)
{
    char * sql = sqlite3_expanded_sql(stmt);
    printf("SQL UPDATE: %s\n", sql);
    sqlite3_free(sql);
}

static void dflt_log_get(void *arg, sqlite3_stmt *stmt)
{
    char * sql = sqlite3_expanded_sql(stmt);
    printf("SQL GET: %s\n", sql);
    sqlite3_free(sql);
}

static void dflt_log_err(void *arg, const std::string &msg)
{
    printf("SQL ERROR: %s\n", msg.c_str());
}

static inline char nibble_to_hex(unsigned char nib)
{
    if (nib > 9)
        return nib - 10 + 'a';
    return nib + '0';
}

static void blob_to_hex(std::string &out, const std::string &in)
{
    out.clear();
    for (size_t ind = 0; ind < in.size(); ind++)
    {
        unsigned char c = (unsigned char) in[ind];
        out += nibble_to_hex((c >> 4) & 0xf);
        out += nibble_to_hex((c >> 0) & 0xf);
    }
}

//static
sql_log_function_t SQL_TABLE_user :: log_upd_func = &dflt_log_upd;
sql_log_function_t SQL_TABLE_user :: log_get_func = &dflt_log_get;
void *             SQL_TABLE_user :: log_arg  = NULL;
sql_err_function_t SQL_TABLE_user :: err_log_func = &dflt_log_err;
void *             SQL_TABLE_user :: err_log_arg  = NULL;

SQL_TABLE_user :: SQL_TABLE_user(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
    xml_decoders_initialized = false;
}

// copy constructor, duplicates all the data fields (including rowid)
// but does not duplicate the statement pointers, because then they'd
// get double-freed.
SQL_TABLE_user :: SQL_TABLE_user(
    const SQL_TABLE_user &other)
{
    init_statements();

    pdb = other.pdb;
    rowid = other.rowid;
    userid = other.userid;
    firstname = other.firstname;
    lastname = other.lastname;
    mi = other.mi;
    SSN = other.SSN;
    balance = other.balance;
    proto = other.proto;
    test2 = other.test2;
    test3 = other.test3;
    checkouts = other.checkouts;

}

void
SQL_TABLE_user :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

    pStmt_by_userid = NULL;
    pStmt_by_SSN = NULL;
    pStmt_by_test2 = NULL;
    pStmt_by_test3 = NULL;

    pStmt_by_lastname_like = NULL;

    pStmt_get_great_balance = NULL;
    pStmt_get_founders = NULL;
    pStmt_get_firstlast = NULL;

    pStmt_update_balance = NULL;
    pStmt_update_firstlast = NULL;
    pStmt_update_by_userid_stuff = NULL;

    pStmt_del_SSN = NULL;


    previous_get = NULL;
    init();
}

SQL_TABLE_user :: ~SQL_TABLE_user(void)
{
    finalize();
}

void
SQL_TABLE_user :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

    if (pStmt_by_userid)
        sqlite3_finalize(pStmt_by_userid);
    if (pStmt_by_SSN)
        sqlite3_finalize(pStmt_by_SSN);
    if (pStmt_by_test2)
        sqlite3_finalize(pStmt_by_test2);
    if (pStmt_by_test3)
        sqlite3_finalize(pStmt_by_test3);

    if (pStmt_by_lastname_like)
        sqlite3_finalize(pStmt_by_lastname_like);

    if (pStmt_get_great_balance)
        sqlite3_finalize(pStmt_get_great_balance);
    if (pStmt_get_founders)
        sqlite3_finalize(pStmt_get_founders);
    if (pStmt_get_firstlast)
        sqlite3_finalize(pStmt_get_firstlast);

    if (pStmt_update_balance)
        sqlite3_finalize(pStmt_update_balance);
    if (pStmt_update_firstlast)
        sqlite3_finalize(pStmt_update_firstlast);
    if (pStmt_update_by_userid_stuff)
        sqlite3_finalize(pStmt_update_by_userid_stuff);

    if (pStmt_del_SSN)
        sqlite3_finalize(pStmt_del_SSN);


    init_statements();
}

void SQL_TABLE_user :: init(void)
{
    rowid = -1;
    userid = -1;
    firstname = "";
    lastname = "";
    mi = "";
    SSN = 0;
    balance = 0;
    proto.clear();
    test2 = false;
    test3 = sample::library2::ENUM_TWO;
    checkouts.clear();

    previous_get = NULL;
}

//static
void
SQL_TABLE_user :: print_err(const char *function, int lineno,
                                     const char *format, ...)
{
    if (err_log_func == NULL)
        // don't bother formatting the args.
        return;

    std::ostringstream msg_out;
    msg_out << function << ":" << lineno << ": ";
    std::string msg = msg_out.str();

    size_t offset = msg.size();
    msg.resize(offset + 250);

    va_list ap;
    va_start(ap, format);
    size_t l = vsnprintf((char*)msg.c_str() + offset,
                         250, format, ap);
    va_end(ap);
    // note that *snprintf returns what it WOULD have written
    // if there was space! so l > msg.size means it truncated.
    if (l < 250)
        msg.resize(l + offset);
    err_log_func(err_log_arg, msg);
}

#undef  PRINT_ERR
#define PRINT_ERR(args...) print_err(__PRETTY_FUNCTION__, __LINE__, args)

bool SQL_TABLE_user :: get_columns(sqlite3_stmt * pStmt)
{
    int got;

    rowid = sqlite3_column_int64(pStmt, 0);

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (userid) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    userid = sqlite3_column_int64(pStmt, 1);
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (firstname) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        firstname.resize(len);
        memcpy((void*)firstname.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (lastname) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 3);
        int len = sqlite3_column_bytes(pStmt, 3);
        lastname.resize(len);
        memcpy((void*)lastname.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (mi) : "
                "column 4 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 4);
        int len = sqlite3_column_bytes(pStmt, 4);
        mi.resize(len);
        memcpy((void*)mi.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (SSN) : "
                "column 5 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    SSN = sqlite3_column_int(pStmt, 5);
    got = sqlite3_column_type(pStmt, 6);
    if (got != SQLITE_FLOAT)
    {
        PRINT_ERR("get_columns (balance) : "
                "column 6 wrong type (%d %d)",
                got, SQLITE_FLOAT);
        return false;
    }
    balance = sqlite3_column_double(pStmt, 6);
    got = sqlite3_column_type(pStmt, 7);
    if (got != SQLITE_BLOB)
    {
        PRINT_ERR("get_columns (proto) : "
                "column 7 wrong type (%d %d)",
                got, SQLITE_BLOB);
        return false;
    }
    {
        const void * ptr = sqlite3_column_blob(
            pStmt, 7);
        int len = sqlite3_column_bytes(pStmt, 7);
        proto.resize(len);
        memcpy((void*)proto.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 8);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (test2) : "
                "column 8 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sqlite3_column_int(pStmt, 8))
        test2 = true;
    else
        test2 = false;
    got = sqlite3_column_type(pStmt, 9);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (test3) : "
                "column 9 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sample::library2::EnumField_t_IsValid(test3))
        test3 = (sample::library2::EnumField_t) sqlite3_column_int(
            pStmt, 9);
    else
        test3 = sample::library2::ENUM_TWO;



    return true;
}

bool SQL_TABLE_user :: get_by_userid(int64_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_userid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE userid = ?",
            -1, &pStmt_by_userid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_userid);

    r = sqlite3_bind_int64(pStmt_by_userid, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_userid);

    r = sqlite3_step(pStmt_by_userid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_userid);
        previous_get = pStmt_by_userid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_SSN(int32_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_SSN == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE SSN = ?",
            -1, &pStmt_by_SSN, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_SSN);

    r = sqlite3_bind_int(pStmt_by_SSN, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_SSN);

    r = sqlite3_step(pStmt_by_SSN);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_SSN);
        previous_get = pStmt_by_SSN;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_test2(bool v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_test2 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE test2 = ?",
            -1, &pStmt_by_test2, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_test2);

    r = sqlite3_bind_int(pStmt_by_test2, 1,
                             v ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_test2);

    r = sqlite3_step(pStmt_by_test2);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_test2);
        previous_get = pStmt_by_test2;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_test3(sample::library2::EnumField_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_test3 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE test3 = ?",
            -1, &pStmt_by_test3, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_test3);

    r = sqlite3_bind_int(pStmt_by_test3, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_test3);

    r = sqlite3_step(pStmt_by_test3);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_test3);
        previous_get = pStmt_by_test3;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: get_by_lastname_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_by_lastname_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE lastname like ?",
            -1, &pStmt_by_lastname_like, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT LIKE for lastname", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_lastname_like);

    r = sqlite3_bind_text(pStmt_by_lastname_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_lastname_like);

    r = sqlite3_step(pStmt_by_lastname_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_lastname_like);
        previous_get = pStmt_by_lastname_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


bool SQL_TABLE_user :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO user "
            "(userid, firstname, lastname, mi, SSN, balance, proto, test2, test3) "
            "values (?,?,?,?,?,?,?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing INSERT", r);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int64(pStmt_insert, 1,
                             userid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind userid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind firstname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 3,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind lastname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 4,
         mi.c_str(), mi.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind mi: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 5,
                             SSN);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind SSN: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_insert, 6,
                             balance);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind balance: r = %d", r);
        return false;
    }
    r = sqlite3_bind_blob(pStmt_insert, 7,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind proto: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 8,
                             test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind test2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 9,
                             (int) test3);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind test3: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("insert: r = %d", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_user :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE user SET "
            "(userid, firstname, lastname, mi, SSN, balance, proto, test2, test3) "
            "= (?,?,?,?,?,?,?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing UPDATE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int64(pStmt_update, 1,
                             userid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind userid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 2,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind firstname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 3,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind lastname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 4,
         mi.c_str(), mi.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind mi: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 5,
                             SSN);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind SSN: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_update, 6,
                             balance);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind balance: r = %d", r);
        return false;
    }
    r = sqlite3_bind_blob(pStmt_update, 7,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind proto: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 8,
                             test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind test2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 9,
                             (int) test3);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind test3: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update,
                           10, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_user :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM user WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing DELETE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("delete: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_user :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_by_rowid", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_all", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

int SQL_TABLE_user :: get_subtable_checkouts(void)
{
    SQL_TABLE_checkouts  row(pdb);
    bool status;
    int count = 0;

    checkouts.clear();
    status = row.get_by_userid2(userid);
    while (status)
    {
        // note this uses the special table class
        // copy constructor that only copies the data,
        // not the prepared statements.
        checkouts.push_back(row);
        count++;
        status = row.get_next();
    }

    return count;
}

bool SQL_TABLE_user :: get_great_balance(double v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_great_balance == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE balance > ?",
            -1, &pStmt_get_great_balance, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET great_balance", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_great_balance);

    r = sqlite3_bind_double(pStmt_get_great_balance,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_great_balance);

    r = sqlite3_step(pStmt_get_great_balance);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_great_balance);
        previous_get = pStmt_get_great_balance;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_founders(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_founders == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE userid < 100",
            -1, &pStmt_get_founders, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET founders", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_founders);



    if (log_get_func)
        log_get_func(log_arg, pStmt_get_founders);

    r = sqlite3_step(pStmt_get_founders);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_founders);
        previous_get = pStmt_get_founders;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_firstlast(const std::string & v1, const std::string & v2)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_firstlast == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE firstname LIKE ? AND lastname LIKE ?",
            -1, &pStmt_get_firstlast, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET firstlast", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_firstlast);

    r = sqlite3_bind_text(pStmt_get_firstlast, 1, 
                          v1.c_str(), v1.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_get_firstlast, 2, 
                          v2.c_str(), v2.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_firstlast);

    r = sqlite3_step(pStmt_get_firstlast);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_firstlast);
        previous_get = pStmt_get_firstlast;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: update_balance(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_balance == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (balance) = "
            "(?) WHERE rowid = ?",
            -1, &pStmt_update_balance, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPD "
                   "balance", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_balance);

    r = sqlite3_bind_double(pStmt_update_balance,
                             1, balance);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind balance: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_balance,
                           2, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_balance);

    r = sqlite3_step(pStmt_update_balance);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update balance: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: update_firstlast(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_firstlast == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (firstname, lastname) = "
            "(?,?) WHERE rowid = ?",
            -1, &pStmt_update_firstlast, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPD "
                   "firstlast", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_firstlast);

    r = sqlite3_bind_text(
        pStmt_update_firstlast, 1,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind firstname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(
        pStmt_update_firstlast, 2,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind lastname: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_firstlast,
                           3, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_firstlast);

    r = sqlite3_step(pStmt_update_firstlast);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update firstlast: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: update_by_userid_stuff(int64_t v1, const std::string & v2)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_by_userid_stuff == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (proto, test2, test3, balance) = "
            "(?,?,?,?) WHERE userid = ? and lastname = ?",
            -1, &pStmt_update_by_userid_stuff, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPDBY "
                      "userid_stuff", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_by_userid_stuff);

    r = sqlite3_bind_blob(
        pStmt_update_by_userid_stuff, 1,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind proto: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update_by_userid_stuff,
                             2, test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind test2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update_by_userid_stuff,
                             3, (int) test3);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind test3: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_update_by_userid_stuff,
                             4, balance);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind balance: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_update_by_userid_stuff,
                             5, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind field 1: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update_by_userid_stuff, 6,
                          v2.c_str(), v2.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind field 2: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_by_userid_stuff);

    r = sqlite3_step(pStmt_update_by_userid_stuff);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update userid_stuff: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: delete_SSN(int32_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if(pStmt_del_SSN == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "DELETE FROM user WHERE ssn = ?",
            -1, &pStmt_del_SSN, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-DEL", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_del_SSN);

    r = sqlite3_bind_int(pStmt_del_SSN,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind arg 1: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_del_SSN);

    r = sqlite3_step(pStmt_del_SSN);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_del_SSN);
        previous_get = pStmt_del_SSN;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

void
SQL_TABLE_user :: CopyToProto(
              library::TABLE_user_m &msg)
{
    msg.set_schema_version(TABLE_VERSION);
    msg.set_userid(userid);
    msg.set_firstname(firstname);
    msg.set_lastname(lastname);
    msg.set_mi(mi);
    msg.set_ssn(SSN);
    msg.set_balance(balance);
    msg.set_proto(proto);
    msg.set_test2(test2 ? true : false);
    if (!sample::library2::EnumField_t_IsValid(test3))
        test3 = sample::library2::ENUM_TWO;

    msg.set_test3(test3);
    msg.clear_checkouts();
    for (size_t ind = 0; ind < checkouts.size(); ind++)
        checkouts[ind].CopyToProto(*msg.add_checkouts());

}

void
SQL_TABLE_user :: CopyFromProto(
              const library::TABLE_user_m &msg)
{
    if (msg.has_schema_version() && msg.schema_version() != TABLE_VERSION)
    {
        // NOTE : if this becomes a problem in the future, we could
        //        enhance sql3gen to allow the user to register a
        //        callback function which can convert a message from
        //        one schema version to another.
        std::ostringstream err;
        err << "SQL_TABLE_user :: "
            << "CopyFromProto : recvd protobuf message with "
            << "schema version " << msg.schema_version()
            << " (supported is " << TABLE_VERSION
            << ")\n";
        if (err_log_func)
            err_log_func(err_log_arg, err.str());
        else
            std::cerr << err.str();
    }
    if (msg.has_userid())
        userid = msg.userid();
    else
        userid = -1;

    if (msg.has_firstname())
        firstname = msg.firstname();
    else
        firstname = "";

    if (msg.has_lastname())
        lastname = msg.lastname();
    else
        lastname = "";

    if (msg.has_mi())
        mi = msg.mi();
    else
        mi = "";

    if (msg.has_ssn())
        SSN = msg.ssn();
    else
        SSN = 0;

    if (msg.has_balance())
        balance = msg.balance();
    else
        balance = 0;

    if (msg.has_proto())
        proto = msg.proto();
    else
        proto.clear();

    if (msg.has_test2())
        test2 = msg.test2() ? true : false;
    else
        test2 = false;

    if (msg.has_test3())
        test3 = msg.test3();
    else
        test3 = sample::library2::ENUM_TWO;

    checkouts.clear();
    checkouts.resize(msg.checkouts_size());
    for (int ind = 0; ind < msg.checkouts_size(); ind++)
    {
        checkouts[ind].set_db(pdb);
        checkouts[ind].CopyFromProto(msg.checkouts(ind));
    }

}

void
SQL_TABLE_user :: CopyToXmlNode(MyXmlNode &node)
{
    node.init();
    node.name = "user";
    {
        MyXmlNode &n = node.add_child();
        n.name = "userid";
        n.attributes["type"] = "pod";
        std::ostringstream s; // not guaranteed to have C++11 features.
        s << userid;
        n.text = s.str();
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "firstname";
        n.attributes["type"] = "text";
        n.text = firstname;
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "lastname";
        n.attributes["type"] = "text";
        n.text = lastname;
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "mi";
        n.attributes["type"] = "text";
        n.text = mi;
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "SSN";
        n.attributes["type"] = "pod";
        std::ostringstream s; // not guaranteed to have C++11 features.
        s << SSN;
        n.text = s.str();
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "balance";
        n.attributes["type"] = "pod";
        std::ostringstream s; // not guaranteed to have C++11 features.
        s << balance;
        n.text = s.str();
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "proto";
        n.attributes["type"] = "blob";
        blob_to_hex(n.text, proto);
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "test2";
        n.attributes["type"] = "bool";
        n.text = test2 ? "true" : "false";
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "test3";
        n.attributes["type"] = "enum sample::library2::EnumField_t";
        n.text = sample::library2::EnumField_t_Name(test3);
    }
// NOTE this adds a bunch of <checkouts> nodes at the same
//      level as all the other fields of this row. need to decide
//      if this is OK or we want a whole subnode for the list.
    for (size_t ind = 0; ind < checkouts.size(); ind++)
    {
        MyXmlNode &n = node.add_child();
        SQL_TABLE_checkouts &f = checkouts[ind];
        f.CopyToXmlNode(n);
        n.attributes["type"] = "subtable";
        std::ostringstream s;
        s << ind;
        n.attributes["index"] = s.str();
    }

}

bool
SQL_TABLE_user :: xml_decoder_userid(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    s >> userid;
    if (s.fail())
        return false;
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_firstname(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        firstname = "";
    else
        firstname = node.children[0].text;
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_lastname(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        lastname = "";
    else
        lastname = node.children[0].text;
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_mi(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        mi = "";
    else
        mi = node.children[0].text;
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_SSN(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    s >> SSN;
    if (s.fail())
        return false;
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_balance(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    s >> balance;
    if (s.fail())
        return false;
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_proto(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        proto.clear();
    else
        proto = node.children[0].text; // xxx decode blob
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_test2(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    std::string s2;
    s >> s2;
    if (s2 == "true")
        test2 = true;
    else if (s2 == "false")
        test2 = false;
    else
        return false;
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_test3(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    return EnumField_t_Parse(node.children[0].text, &test3);
}
bool
SQL_TABLE_user :: xml_decoder_checkouts(const MyXmlNode &node)
{
    SQL_TABLE_checkouts  row(pdb);
    if (row.CopyFromXmlNode(node) == false)
        return false;
    checkouts.push_back(row);
    return true;
}


bool
SQL_TABLE_user :: CopyFromXmlNode(const MyXmlNode &node)
{
    init();
    if (xml_decoders_initialized == false)
    {
        xml_decoders["userid"] =
            &SQL_TABLE_user::xml_decoder_userid;
        xml_decoders["firstname"] =
            &SQL_TABLE_user::xml_decoder_firstname;
        xml_decoders["lastname"] =
            &SQL_TABLE_user::xml_decoder_lastname;
        xml_decoders["mi"] =
            &SQL_TABLE_user::xml_decoder_mi;
        xml_decoders["SSN"] =
            &SQL_TABLE_user::xml_decoder_SSN;
        xml_decoders["balance"] =
            &SQL_TABLE_user::xml_decoder_balance;
        xml_decoders["proto"] =
            &SQL_TABLE_user::xml_decoder_proto;
        xml_decoders["test2"] =
            &SQL_TABLE_user::xml_decoder_test2;
        xml_decoders["test3"] =
            &SQL_TABLE_user::xml_decoder_test3;
        xml_decoders["checkouts"] =
            &SQL_TABLE_user::xml_decoder_checkouts;

        xml_decoders_initialized = true;
    }
    if (node.name != "user")
    {
        if (err_log_func)
        {
            std::ostringstream err;
            err << "SQL_TABLE_user :: "
                << "CopyFromXmlNode : node name is " << node.name
                << " not 'user'!\n";
            err_log_func(err_log_arg, err.str().c_str());
        }
        return false;
    }
    for (size_t ind = 0; ind < node.children.size(); ind++)
    {
        const MyXmlNode &n = node.children[ind];
        if (n.name.size() == 0)
            continue;
        xml_decoder_map_t::iterator it = xml_decoders.find(n.name);
        if (it != xml_decoders.end())
        {
            xml_decoder_func_t f = it->second;
            if ((this->*f)(n) == false)
                return false;
        }
    }
    return true;
}


//static
bool SQL_TABLE_user :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"user\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("select from tables: %d", r);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"user\",19)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "user", v, 19);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (19) "
            "WHERE name = \"user\"",
            NULL, NULL, NULL);
    }
    else
    {
        PRINT_ERR("select from tables / step r = %d", r);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_user :: table_create(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    sqlite3_exec(pdb, "CREATE TABLE user "
        "(userid int64 NOT NULL UNIQUE, firstname string NOT NULL, lastname string NOT NULL, mi string, SSN integer NOT NULL UNIQUE, balance double, proto blob, test2 integer, test3 integer)",
        NULL, NULL, NULL);

    printf("CREATE TABLE: CREATE TABLE user "
           "(userid int64 NOT NULL UNIQUE, firstname string NOT NULL, lastname string NOT NULL, mi string, SSN integer NOT NULL UNIQUE, balance double, proto blob, test2 integer, test3 integer)\n");

    sqlite3_exec(pdb,"CREATE INDEX user_userid "
                 "ON user (userid)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX user_userid "
           "ON user (userid)\n");
    sqlite3_exec(pdb,"CREATE INDEX user_SSN "
                 "ON user (SSN)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX user_SSN "
           "ON user (SSN)\n");


    return true;
}

//static
void SQL_TABLE_user :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE user",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE user\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}


//static
sql_log_function_t SQL_TABLE_book :: log_upd_func = &dflt_log_upd;
sql_log_function_t SQL_TABLE_book :: log_get_func = &dflt_log_get;
void *             SQL_TABLE_book :: log_arg  = NULL;
sql_err_function_t SQL_TABLE_book :: err_log_func = &dflt_log_err;
void *             SQL_TABLE_book :: err_log_arg  = NULL;

SQL_TABLE_book :: SQL_TABLE_book(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
    xml_decoders_initialized = false;
}

// copy constructor, duplicates all the data fields (including rowid)
// but does not duplicate the statement pointers, because then they'd
// get double-freed.
SQL_TABLE_book :: SQL_TABLE_book(
    const SQL_TABLE_book &other)
{
    init_statements();

    pdb = other.pdb;
    rowid = other.rowid;
    bookid = other.bookid;
    title = other.title;
    isbn = other.isbn;
    price = other.price;
    quantity = other.quantity;
    checkouts = other.checkouts;

}

void
SQL_TABLE_book :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

    pStmt_by_bookid = NULL;
    pStmt_by_isbn = NULL;

    pStmt_by_title_like = NULL;

    pStmt_get_out_of_stock = NULL;

    pStmt_update_quantity = NULL;
    pStmt_update_price = NULL;



    previous_get = NULL;
    init();
}

SQL_TABLE_book :: ~SQL_TABLE_book(void)
{
    finalize();
}

void
SQL_TABLE_book :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

    if (pStmt_by_bookid)
        sqlite3_finalize(pStmt_by_bookid);
    if (pStmt_by_isbn)
        sqlite3_finalize(pStmt_by_isbn);

    if (pStmt_by_title_like)
        sqlite3_finalize(pStmt_by_title_like);

    if (pStmt_get_out_of_stock)
        sqlite3_finalize(pStmt_get_out_of_stock);

    if (pStmt_update_quantity)
        sqlite3_finalize(pStmt_update_quantity);
    if (pStmt_update_price)
        sqlite3_finalize(pStmt_update_price);



    init_statements();
}

void SQL_TABLE_book :: init(void)
{
    rowid = -1;
    bookid = 0;
    title = "";
    isbn = "";
    price = 0;
    quantity = 0;
    checkouts.clear();

    previous_get = NULL;
}

//static
void
SQL_TABLE_book :: print_err(const char *function, int lineno,
                                     const char *format, ...)
{
    if (err_log_func == NULL)
        // don't bother formatting the args.
        return;

    std::ostringstream msg_out;
    msg_out << function << ":" << lineno << ": ";
    std::string msg = msg_out.str();

    size_t offset = msg.size();
    msg.resize(offset + 250);

    va_list ap;
    va_start(ap, format);
    size_t l = vsnprintf((char*)msg.c_str() + offset,
                         250, format, ap);
    va_end(ap);
    // note that *snprintf returns what it WOULD have written
    // if there was space! so l > msg.size means it truncated.
    if (l < 250)
        msg.resize(l + offset);
    err_log_func(err_log_arg, msg);
}

#undef  PRINT_ERR
#define PRINT_ERR(args...) print_err(__PRETTY_FUNCTION__, __LINE__, args)

bool SQL_TABLE_book :: get_columns(sqlite3_stmt * pStmt)
{
    int got;

    rowid = sqlite3_column_int64(pStmt, 0);

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (bookid) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    bookid = sqlite3_column_int64(pStmt, 1);
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (title) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        title.resize(len);
        memcpy((void*)title.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (isbn) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 3);
        int len = sqlite3_column_bytes(pStmt, 3);
        isbn.resize(len);
        memcpy((void*)isbn.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_FLOAT)
    {
        PRINT_ERR("get_columns (price) : "
                "column 4 wrong type (%d %d)",
                got, SQLITE_FLOAT);
        return false;
    }
    price = sqlite3_column_double(pStmt, 4);
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (quantity) : "
                "column 5 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    quantity = sqlite3_column_int(pStmt, 5);


    return true;
}

bool SQL_TABLE_book :: get_by_bookid(int64_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_bookid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book WHERE bookid = ?",
            -1, &pStmt_by_bookid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_bookid);

    r = sqlite3_bind_int64(pStmt_by_bookid, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_bookid);

    r = sqlite3_step(pStmt_by_bookid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_bookid);
        previous_get = pStmt_by_bookid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_book :: get_by_isbn(const std::string & v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_isbn == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book WHERE isbn = ?",
            -1, &pStmt_by_isbn, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_isbn);

    r = sqlite3_bind_text(pStmt_by_isbn, 1,
         v.c_str(), v.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_isbn);

    r = sqlite3_step(pStmt_by_isbn);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_isbn);
        previous_get = pStmt_by_isbn;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: get_by_title_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_by_title_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book "
            "WHERE title like ?",
            -1, &pStmt_by_title_like, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT LIKE for title", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_title_like);

    r = sqlite3_bind_text(pStmt_by_title_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_title_like);

    r = sqlite3_step(pStmt_by_title_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_title_like);
        previous_get = pStmt_by_title_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


bool SQL_TABLE_book :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO book "
            "(bookid, title, isbn, price, quantity) "
            "values (?,?,?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing INSERT", r);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int64(pStmt_insert, 1,
                             bookid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind bookid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         title.c_str(), title.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind title: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 3,
         isbn.c_str(), isbn.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind isbn: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_insert, 4,
                             price);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind price: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 5,
                             quantity);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind quantity: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("insert: r = %d", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_book :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE book SET "
            "(bookid, title, isbn, price, quantity) "
            "= (?,?,?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing UPDATE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int64(pStmt_update, 1,
                             bookid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind bookid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 2,
         title.c_str(), title.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind title: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 3,
         isbn.c_str(), isbn.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind isbn: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_update, 4,
                             price);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind price: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 5,
                             quantity);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind quantity: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update,
                           6, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_book :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM book WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing DELETE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("delete: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_book :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_by_rowid", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_all", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

int SQL_TABLE_book :: get_subtable_checkouts(void)
{
    SQL_TABLE_checkouts  row(pdb);
    bool status;
    int count = 0;

    checkouts.clear();
    status = row.get_by_bookid2(bookid);
    while (status)
    {
        // note this uses the special table class
        // copy constructor that only copies the data,
        // not the prepared statements.
        checkouts.push_back(row);
        count++;
        status = row.get_next();
    }

    return count;
}

bool SQL_TABLE_book :: get_out_of_stock(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_out_of_stock == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book "
            "WHERE quantity == 0",
            -1, &pStmt_get_out_of_stock, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET out_of_stock", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_out_of_stock);



    if (log_get_func)
        log_get_func(log_arg, pStmt_get_out_of_stock);

    r = sqlite3_step(pStmt_get_out_of_stock);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_out_of_stock);
        previous_get = pStmt_get_out_of_stock;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: update_quantity(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_quantity == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE book SET (quantity) = "
            "(?) WHERE rowid = ?",
            -1, &pStmt_update_quantity, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPD "
                   "quantity", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_quantity);

    r = sqlite3_bind_int(pStmt_update_quantity,
                             1, quantity);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind quantity: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_quantity,
                           2, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_quantity);

    r = sqlite3_step(pStmt_update_quantity);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update quantity: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
bool SQL_TABLE_book :: update_price(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_price == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE book SET (price) = "
            "(?) WHERE rowid = ?",
            -1, &pStmt_update_price, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPD "
                   "price", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_price);

    r = sqlite3_bind_double(pStmt_update_price,
                             1, price);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind price: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_price,
                           2, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_price);

    r = sqlite3_step(pStmt_update_price);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update price: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}


void
SQL_TABLE_book :: CopyToProto(
              library::TABLE_book_m &msg)
{
    msg.set_schema_version(TABLE_VERSION);
    msg.set_bookid(bookid);
    msg.set_title(title);
    msg.set_isbn(isbn);
    msg.set_price(price);
    msg.set_quantity(quantity);
    msg.clear_checkouts();
    for (size_t ind = 0; ind < checkouts.size(); ind++)
        checkouts[ind].CopyToProto(*msg.add_checkouts());

}

void
SQL_TABLE_book :: CopyFromProto(
              const library::TABLE_book_m &msg)
{
    if (msg.has_schema_version() && msg.schema_version() != TABLE_VERSION)
    {
        // NOTE : if this becomes a problem in the future, we could
        //        enhance sql3gen to allow the user to register a
        //        callback function which can convert a message from
        //        one schema version to another.
        std::ostringstream err;
        err << "SQL_TABLE_book :: "
            << "CopyFromProto : recvd protobuf message with "
            << "schema version " << msg.schema_version()
            << " (supported is " << TABLE_VERSION
            << ")\n";
        if (err_log_func)
            err_log_func(err_log_arg, err.str());
        else
            std::cerr << err.str();
    }
    if (msg.has_bookid())
        bookid = msg.bookid();
    else
        bookid = 0;

    if (msg.has_title())
        title = msg.title();
    else
        title = "";

    if (msg.has_isbn())
        isbn = msg.isbn();
    else
        isbn = "";

    if (msg.has_price())
        price = msg.price();
    else
        price = 0;

    if (msg.has_quantity())
        quantity = msg.quantity();
    else
        quantity = 0;

    checkouts.clear();
    checkouts.resize(msg.checkouts_size());
    for (int ind = 0; ind < msg.checkouts_size(); ind++)
    {
        checkouts[ind].set_db(pdb);
        checkouts[ind].CopyFromProto(msg.checkouts(ind));
    }

}

void
SQL_TABLE_book :: CopyToXmlNode(MyXmlNode &node)
{
    node.init();
    node.name = "book";
    {
        MyXmlNode &n = node.add_child();
        n.name = "bookid";
        n.attributes["type"] = "pod";
        std::ostringstream s; // not guaranteed to have C++11 features.
        s << bookid;
        n.text = s.str();
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "title";
        n.attributes["type"] = "text";
        n.text = title;
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "isbn";
        n.attributes["type"] = "text";
        n.text = isbn;
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "price";
        n.attributes["type"] = "pod";
        std::ostringstream s; // not guaranteed to have C++11 features.
        s << price;
        n.text = s.str();
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "quantity";
        n.attributes["type"] = "pod";
        std::ostringstream s; // not guaranteed to have C++11 features.
        s << quantity;
        n.text = s.str();
    }
// NOTE this adds a bunch of <checkouts> nodes at the same
//      level as all the other fields of this row. need to decide
//      if this is OK or we want a whole subnode for the list.
    for (size_t ind = 0; ind < checkouts.size(); ind++)
    {
        MyXmlNode &n = node.add_child();
        SQL_TABLE_checkouts &f = checkouts[ind];
        f.CopyToXmlNode(n);
        n.attributes["type"] = "subtable";
        std::ostringstream s;
        s << ind;
        n.attributes["index"] = s.str();
    }

}

bool
SQL_TABLE_book :: xml_decoder_bookid(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    s >> bookid;
    if (s.fail())
        return false;
    return true;
}
bool
SQL_TABLE_book :: xml_decoder_title(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        title = "";
    else
        title = node.children[0].text;
    return true;
}
bool
SQL_TABLE_book :: xml_decoder_isbn(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        isbn = "";
    else
        isbn = node.children[0].text;
    return true;
}
bool
SQL_TABLE_book :: xml_decoder_price(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    s >> price;
    if (s.fail())
        return false;
    return true;
}
bool
SQL_TABLE_book :: xml_decoder_quantity(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    s >> quantity;
    if (s.fail())
        return false;
    return true;
}
bool
SQL_TABLE_book :: xml_decoder_checkouts(const MyXmlNode &node)
{
    SQL_TABLE_checkouts  row(pdb);
    if (row.CopyFromXmlNode(node) == false)
        return false;
    checkouts.push_back(row);
    return true;
}


bool
SQL_TABLE_book :: CopyFromXmlNode(const MyXmlNode &node)
{
    init();
    if (xml_decoders_initialized == false)
    {
        xml_decoders["bookid"] =
            &SQL_TABLE_book::xml_decoder_bookid;
        xml_decoders["title"] =
            &SQL_TABLE_book::xml_decoder_title;
        xml_decoders["isbn"] =
            &SQL_TABLE_book::xml_decoder_isbn;
        xml_decoders["price"] =
            &SQL_TABLE_book::xml_decoder_price;
        xml_decoders["quantity"] =
            &SQL_TABLE_book::xml_decoder_quantity;
        xml_decoders["checkouts"] =
            &SQL_TABLE_book::xml_decoder_checkouts;

        xml_decoders_initialized = true;
    }
    if (node.name != "book")
    {
        if (err_log_func)
        {
            std::ostringstream err;
            err << "SQL_TABLE_book :: "
                << "CopyFromXmlNode : node name is " << node.name
                << " not 'book'!\n";
            err_log_func(err_log_arg, err.str().c_str());
        }
        return false;
    }
    for (size_t ind = 0; ind < node.children.size(); ind++)
    {
        const MyXmlNode &n = node.children[ind];
        if (n.name.size() == 0)
            continue;
        xml_decoder_map_t::iterator it = xml_decoders.find(n.name);
        if (it != xml_decoders.end())
        {
            xml_decoder_func_t f = it->second;
            if ((this->*f)(n) == false)
                return false;
        }
    }
    return true;
}


//static
bool SQL_TABLE_book :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"book\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("select from tables: %d", r);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"book\",1)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "book", v, 1);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (1) "
            "WHERE name = \"book\"",
            NULL, NULL, NULL);
    }
    else
    {
        PRINT_ERR("select from tables / step r = %d", r);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_book :: table_create(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    sqlite3_exec(pdb, "CREATE TABLE book "
        "(bookid int64 NOT NULL UNIQUE, title string NOT NULL, isbn string NOT NULL UNIQUE, price double, quantity integer)",
        NULL, NULL, NULL);

    printf("CREATE TABLE: CREATE TABLE book "
           "(bookid int64 NOT NULL UNIQUE, title string NOT NULL, isbn string NOT NULL UNIQUE, price double, quantity integer)\n");

    sqlite3_exec(pdb,"CREATE INDEX book_bookid "
                 "ON book (bookid)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX book_bookid "
           "ON book (bookid)\n");
    sqlite3_exec(pdb,"CREATE INDEX book_isbn "
                 "ON book (isbn)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX book_isbn "
           "ON book (isbn)\n");


    return true;
}

//static
void SQL_TABLE_book :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE book",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE book\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}


//static
sql_log_function_t SQL_TABLE_checkouts :: log_upd_func = &dflt_log_upd;
sql_log_function_t SQL_TABLE_checkouts :: log_get_func = &dflt_log_get;
void *             SQL_TABLE_checkouts :: log_arg  = NULL;
sql_err_function_t SQL_TABLE_checkouts :: err_log_func = &dflt_log_err;
void *             SQL_TABLE_checkouts :: err_log_arg  = NULL;

SQL_TABLE_checkouts :: SQL_TABLE_checkouts(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
    xml_decoders_initialized = false;
}

// copy constructor, duplicates all the data fields (including rowid)
// but does not duplicate the statement pointers, because then they'd
// get double-freed.
SQL_TABLE_checkouts :: SQL_TABLE_checkouts(
    const SQL_TABLE_checkouts &other)
{
    init_statements();

    pdb = other.pdb;
    rowid = other.rowid;
    bookid2 = other.bookid2;
    userid2 = other.userid2;
    duedate = other.duedate;

}

void
SQL_TABLE_checkouts :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

    pStmt_by_bookid2 = NULL;
    pStmt_by_userid2 = NULL;


    pStmt_get_due_now = NULL;




    previous_get = NULL;
    init();
}

SQL_TABLE_checkouts :: ~SQL_TABLE_checkouts(void)
{
    finalize();
}

void
SQL_TABLE_checkouts :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

    if (pStmt_by_bookid2)
        sqlite3_finalize(pStmt_by_bookid2);
    if (pStmt_by_userid2)
        sqlite3_finalize(pStmt_by_userid2);


    if (pStmt_get_due_now)
        sqlite3_finalize(pStmt_get_due_now);




    init_statements();
}

void SQL_TABLE_checkouts :: init(void)
{
    rowid = -1;
    bookid2 = 0;
    userid2 = 0;
    duedate = 0;

    previous_get = NULL;
}

//static
void
SQL_TABLE_checkouts :: print_err(const char *function, int lineno,
                                     const char *format, ...)
{
    if (err_log_func == NULL)
        // don't bother formatting the args.
        return;

    std::ostringstream msg_out;
    msg_out << function << ":" << lineno << ": ";
    std::string msg = msg_out.str();

    size_t offset = msg.size();
    msg.resize(offset + 250);

    va_list ap;
    va_start(ap, format);
    size_t l = vsnprintf((char*)msg.c_str() + offset,
                         250, format, ap);
    va_end(ap);
    // note that *snprintf returns what it WOULD have written
    // if there was space! so l > msg.size means it truncated.
    if (l < 250)
        msg.resize(l + offset);
    err_log_func(err_log_arg, msg);
}

#undef  PRINT_ERR
#define PRINT_ERR(args...) print_err(__PRETTY_FUNCTION__, __LINE__, args)

bool SQL_TABLE_checkouts :: get_columns(sqlite3_stmt * pStmt)
{
    int got;

    rowid = sqlite3_column_int64(pStmt, 0);

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (bookid2) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    bookid2 = sqlite3_column_int64(pStmt, 1);
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (userid2) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    userid2 = sqlite3_column_int64(pStmt, 2);
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (duedate) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    duedate = sqlite3_column_int64(pStmt, 3);


    return true;
}

bool SQL_TABLE_checkouts :: get_by_bookid2(int64_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_bookid2 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts WHERE bookid2 = ?",
            -1, &pStmt_by_bookid2, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_bookid2);

    r = sqlite3_bind_int64(pStmt_by_bookid2, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_bookid2);

    r = sqlite3_step(pStmt_by_bookid2);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_bookid2);
        previous_get = pStmt_by_bookid2;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_checkouts :: get_by_userid2(int64_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_userid2 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts WHERE userid2 = ?",
            -1, &pStmt_by_userid2, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_userid2);

    r = sqlite3_bind_int64(pStmt_by_userid2, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_userid2);

    r = sqlite3_step(pStmt_by_userid2);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_userid2);
        previous_get = pStmt_by_userid2;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}



bool SQL_TABLE_checkouts :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_checkouts :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO checkouts "
            "(bookid2, userid2, duedate) "
            "values (?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing INSERT", r);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int64(pStmt_insert, 1,
                             bookid2);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind bookid2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_insert, 2,
                             userid2);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind userid2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_insert, 3,
                             duedate);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind duedate: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("insert: r = %d", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_checkouts :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE checkouts SET "
            "(bookid2, userid2, duedate) "
            "= (?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing UPDATE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int64(pStmt_update, 1,
                             bookid2);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind bookid2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_update, 2,
                             userid2);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind userid2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_update, 3,
                             duedate);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind duedate: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update,
                           4, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_checkouts :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM checkouts WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing DELETE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("delete: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_checkouts :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_by_rowid", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_checkouts :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_all", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


bool SQL_TABLE_checkouts :: get_due_now(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_due_now == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts "
            "WHERE duedate < ?",
            -1, &pStmt_get_due_now, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET due_now", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_due_now);

    r = sqlite3_bind_int64(pStmt_get_due_now,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_due_now);

    r = sqlite3_step(pStmt_get_due_now);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_due_now);
        previous_get = pStmt_get_due_now;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}



void
SQL_TABLE_checkouts :: CopyToProto(
              library::TABLE_checkouts_m &msg)
{
    msg.set_schema_version(TABLE_VERSION);
    msg.set_bookid2(bookid2);
    msg.set_userid2(userid2);
    msg.set_duedate(duedate);

}

void
SQL_TABLE_checkouts :: CopyFromProto(
              const library::TABLE_checkouts_m &msg)
{
    if (msg.has_schema_version() && msg.schema_version() != TABLE_VERSION)
    {
        // NOTE : if this becomes a problem in the future, we could
        //        enhance sql3gen to allow the user to register a
        //        callback function which can convert a message from
        //        one schema version to another.
        std::ostringstream err;
        err << "SQL_TABLE_checkouts :: "
            << "CopyFromProto : recvd protobuf message with "
            << "schema version " << msg.schema_version()
            << " (supported is " << TABLE_VERSION
            << ")\n";
        if (err_log_func)
            err_log_func(err_log_arg, err.str());
        else
            std::cerr << err.str();
    }
    if (msg.has_bookid2())
        bookid2 = msg.bookid2();
    else
        bookid2 = 0;

    if (msg.has_userid2())
        userid2 = msg.userid2();
    else
        userid2 = 0;

    if (msg.has_duedate())
        duedate = msg.duedate();
    else
        duedate = 0;


}

void
SQL_TABLE_checkouts :: CopyToXmlNode(MyXmlNode &node)
{
    node.init();
    node.name = "checkouts";
    {
        MyXmlNode &n = node.add_child();
        n.name = "bookid2";
        n.attributes["type"] = "pod";
        std::ostringstream s; // not guaranteed to have C++11 features.
        s << bookid2;
        n.text = s.str();
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "userid2";
        n.attributes["type"] = "pod";
        std::ostringstream s; // not guaranteed to have C++11 features.
        s << userid2;
        n.text = s.str();
    }
    {
        MyXmlNode &n = node.add_child();
        n.name = "duedate";
        n.attributes["type"] = "pod";
        std::ostringstream s; // not guaranteed to have C++11 features.
        s << duedate;
        n.text = s.str();
    }

}

bool
SQL_TABLE_checkouts :: xml_decoder_bookid2(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    s >> bookid2;
    if (s.fail())
        return false;
    return true;
}
bool
SQL_TABLE_checkouts :: xml_decoder_userid2(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    s >> userid2;
    if (s.fail())
        return false;
    return true;
}
bool
SQL_TABLE_checkouts :: xml_decoder_duedate(const MyXmlNode &node)
{
    if (node.children.size() == 0)
        return false;
    std::istringstream s(node.children[0].text);
    s >> duedate;
    if (s.fail())
        return false;
    return true;
}


bool
SQL_TABLE_checkouts :: CopyFromXmlNode(const MyXmlNode &node)
{
    init();
    if (xml_decoders_initialized == false)
    {
        xml_decoders["bookid2"] =
            &SQL_TABLE_checkouts::xml_decoder_bookid2;
        xml_decoders["userid2"] =
            &SQL_TABLE_checkouts::xml_decoder_userid2;
        xml_decoders["duedate"] =
            &SQL_TABLE_checkouts::xml_decoder_duedate;

        xml_decoders_initialized = true;
    }
    if (node.name != "checkouts")
    {
        if (err_log_func)
        {
            std::ostringstream err;
            err << "SQL_TABLE_checkouts :: "
                << "CopyFromXmlNode : node name is " << node.name
                << " not 'checkouts'!\n";
            err_log_func(err_log_arg, err.str().c_str());
        }
        return false;
    }
    for (size_t ind = 0; ind < node.children.size(); ind++)
    {
        const MyXmlNode &n = node.children[ind];
        if (n.name.size() == 0)
            continue;
        xml_decoder_map_t::iterator it = xml_decoders.find(n.name);
        if (it != xml_decoders.end())
        {
            xml_decoder_func_t f = it->second;
            if ((this->*f)(n) == false)
                return false;
        }
    }
    return true;
}


//static
bool SQL_TABLE_checkouts :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"checkouts\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("select from tables: %d", r);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"checkouts\",1)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "checkouts", v, 1);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (1) "
            "WHERE name = \"checkouts\"",
            NULL, NULL, NULL);
    }
    else
    {
        PRINT_ERR("select from tables / step r = %d", r);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_checkouts :: table_create(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    sqlite3_exec(pdb, "CREATE TABLE checkouts "
        "(bookid2 int64 UNIQUE, userid2 int64, duedate int64, FOREIGN KEY(bookid2) REFERENCES book(bookid), FOREIGN KEY(userid2) REFERENCES user(userid))",
        NULL, NULL, NULL);

    printf("CREATE TABLE: CREATE TABLE checkouts "
           "(bookid2 int64 UNIQUE, userid2 int64, duedate int64, FOREIGN KEY(bookid2) REFERENCES book(bookid), FOREIGN KEY(userid2) REFERENCES user(userid))\n");

    sqlite3_exec(pdb,"CREATE INDEX checkouts_bookid2 "
                 "ON checkouts (bookid2)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX checkouts_bookid2 "
           "ON checkouts (bookid2)\n");
    sqlite3_exec(pdb,"CREATE INDEX checkouts_userid2 "
                 "ON checkouts (userid2)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX checkouts_userid2 "
           "ON checkouts (userid2)\n");


    return true;
}

//static
void SQL_TABLE_checkouts :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE checkouts",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE checkouts\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}


bool SQL_TABLE_ALL_TABLES :: init_all(sqlite3 *pdb, table_version_callback cb)
{
    sqlite3_stmt * s;
    sqlite3_prepare_v2(pdb,
        "select * from sqlite_master "
        "where name = \"tables\" and type = \"table\"",
        -1, &s, NULL);
    sqlite3_reset(s);
    int r = sqlite3_step(s);
    if (r == SQLITE_DONE)
    {
        // the table does NOT exist, create it
        sqlite3_exec(pdb,
                     "CREATE TABLE tables (name text, version int)",
                     NULL, NULL, NULL);
    }
    sqlite3_finalize(s);

    if (!SQL_TABLE_user::init(pdb, cb))
        return false;
    if (!SQL_TABLE_book::init(pdb, cb))
        return false;
    if (!SQL_TABLE_checkouts::init(pdb, cb))
        return false;


    return true;
}

void SQL_TABLE_ALL_TABLES :: table_drop_all(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        fprintf(stderr, "attempted DROP (all) with null db\n");
        return;
    }

    SQL_TABLE_user::table_drop(pdb);
    SQL_TABLE_book::table_drop(pdb);
    SQL_TABLE_checkouts::table_drop(pdb);


    sqlite3_exec(pdb,
                 "DROP TABLE tables",
                 NULL, NULL, NULL);
}

}; // namespace library


/* source bottom line 1 */
/* source bottom line 2 */


