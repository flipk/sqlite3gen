
///////////////////////////////////////////////////////////
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
//                                                       //
//       THIS FILE IS AUTOGENERATED BY sqlite3gen        //
// DO NOT EDIT THIS FILE, EDIT THE SOURCE AND REGENERATE //
//                                                       //
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
///////////////////////////////////////////////////////////

#include "sample.h"
#include <string.h>
#include <stdio.h>
#include <sstream>
#include <iostream>
#include <iomanip>


/* source top line 1 */
/* source top line 2 */


namespace library {

#define PRINT_ERR(args...) SQL_TABLE_ALL_TABLES::print_err(\
        __PRETTY_FUNCTION__, __LINE__, args)

#define log_row_func SQL_TABLE_ALL_TABLES::log_row_func
#define log_get_func SQL_TABLE_ALL_TABLES::log_get_func
#define log_upd_func SQL_TABLE_ALL_TABLES::log_upd_func
#define err_log_func SQL_TABLE_ALL_TABLES::err_log_func
#define      log_arg SQL_TABLE_ALL_TABLES::log_arg

static void dflt_log_upd(void *arg, sqlite3_stmt *stmt)
{
    char * sql = sqlite3_expanded_sql(stmt);
    printf("SQL UPDATE: %s\n", sql);
    sqlite3_free(sql);
}

static void dflt_log_get(void *arg, sqlite3_stmt *stmt)
{
    char * sql = sqlite3_expanded_sql(stmt);
    printf("SQL GET: %s\n", sql);
    sqlite3_free(sql);
}

static void dflt_log_row(void *arg, const std::string &msg)
{
    printf("SQL ROW: %s\n", msg.c_str());
}

static void dflt_log_err(void *arg, const std::string &msg)
{
    printf("SQL ERROR: %s\n", msg.c_str());
}

static inline char nibble_to_hex(unsigned char nib)
{
    if (nib > 9)
        return nib - 10 + 'a';
    return nib + '0';
}

static void blob_to_hex(std::string &out, const std::string &in)
{
    out.clear();
    for (size_t ind = 0; ind < in.size(); ind++)
    {
        unsigned char c = (unsigned char) in[ind];
        out += nibble_to_hex((c >> 4) & 0xf);
        out += nibble_to_hex((c >> 0) & 0xf);
    }
}

static char hex_to_nibble(char c)
{
    if (c >= '0' && c <= '9')
        return c - '0';
    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    return 0xff;
}

static bool hex_to_blob(std::string &out, const std::string &in)
{
    if ((in.size() % 2) == 1)
        return false;

    out.clear();
    for (size_t ind = 0; ind < in.size(); ind += 2)
    {
        char l = hex_to_nibble(in[ind]);
        char r = hex_to_nibble(in[ind+1]);
        if (l == 0xff || r == 0xff)
            return false;
        char c = (l << 4) + r;
        out += c;
    }

    return true;
}

void _____dummy_blob_spacer(void)
{
    // this func exists only to eliminate 'defined but not used'
    // warnings on the above static funcs.
    std::string a,b;
    hex_to_blob(a,b);
    blob_to_hex(a,b);
}

SQL_TABLE_user :: SQL_TABLE_user(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
    xml_decoders_initialized = false;
#endif
}

// copy constructor, duplicates all the data fields (including rowid)
// but does not duplicate the statement pointers, because then they'd
// get double-freed.
SQL_TABLE_user :: SQL_TABLE_user(
    const SQL_TABLE_user &other)
{
    init_statements();
    operator=(other);
}

void
SQL_TABLE_user :: operator=(const SQL_TABLE_user &other)
{
    pdb = other.pdb;
    rowid = other.rowid;
    userid = other.userid;
    firstname = other.firstname;
    lastname = other.lastname;
    mi = other.mi;
    SSN = other.SSN;
    balance = other.balance;
    proto = other.proto;
    test2 = other.test2;
    test3 = other.test3;
    checkouts = other.checkouts;

}

void
SQL_TABLE_user :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_insert_force = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

    pStmt_by_userid = NULL;
    pStmt_by_SSN = NULL;
    pStmt_by_test2 = NULL;
    pStmt_by_test3 = NULL;

    pStmt_by_lastname_like = NULL;

    pStmt_get_great_balance = NULL;
    pStmt_get_founders = NULL;
    pStmt_get_firstlast = NULL;

    pStmt_update_balance = NULL;
    pStmt_update_firstlast = NULL;
    pStmt_update_by_userid_stuff = NULL;

    pStmt_del_SSN = NULL;


    previous_get = NULL;
    init();
}

SQL_TABLE_user :: ~SQL_TABLE_user(void)
{
    finalize();
}

void
SQL_TABLE_user :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_insert_force)
        sqlite3_finalize(pStmt_insert_force);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

    if (pStmt_by_userid)
        sqlite3_finalize(pStmt_by_userid);
    if (pStmt_by_SSN)
        sqlite3_finalize(pStmt_by_SSN);
    if (pStmt_by_test2)
        sqlite3_finalize(pStmt_by_test2);
    if (pStmt_by_test3)
        sqlite3_finalize(pStmt_by_test3);

    if (pStmt_by_lastname_like)
        sqlite3_finalize(pStmt_by_lastname_like);

    if (pStmt_get_great_balance)
        sqlite3_finalize(pStmt_get_great_balance);
    if (pStmt_get_founders)
        sqlite3_finalize(pStmt_get_founders);
    if (pStmt_get_firstlast)
        sqlite3_finalize(pStmt_get_firstlast);

    if (pStmt_update_balance)
        sqlite3_finalize(pStmt_update_balance);
    if (pStmt_update_firstlast)
        sqlite3_finalize(pStmt_update_firstlast);
    if (pStmt_update_by_userid_stuff)
        sqlite3_finalize(pStmt_update_by_userid_stuff);

    if (pStmt_del_SSN)
        sqlite3_finalize(pStmt_del_SSN);


    init_statements();
}

void SQL_TABLE_user :: init(void)
{
    rowid = -1;
    userid = -1;
    firstname = "";
    lastname = "";
    mi = "";
    SSN = 0;
    balance = 0;
    proto.clear();
    test2 = false;
    test3 = sample::library2::ENUM_TWO;
    checkouts.clear();

    previous_get = NULL;
}

//static
void SQL_TABLE_user :: get_column_descriptors(
    std::vector<SQL_Column_Descriptor> &columns)
{
    SQL_Column_Descriptor desc;
    columns.clear();

    desc.tablename = "user";
    desc.fieldname = "userid";
    desc.ctype = "int32_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "firstname";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "lastname";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "mi";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "SSN";
    desc.ctype = "int32_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "balance";
    desc.ctype = "double";
    desc.sqlite_type = SQLITE_FLOAT;
    desc.sqlite3gen_type = TYPE_DOUBLE;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "proto";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_BLOB;
    desc.sqlite3gen_type = TYPE_BLOB;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "test2";
    desc.ctype = "bool";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_BOOL;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "test3";
    desc.ctype = "sample::library2::EnumField_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_ENUM;
    columns.push_back(desc);

}

std::string SQL_TABLE_user :: rowid_toString(void)
{
    std::ostringstream out;
    out << rowid;
    return out.str();
}

std::string
SQL_TABLE_user :: userid_toString(void)
{
    std::ostringstream out;
    out << userid;
    return out.str();
}
std::string
SQL_TABLE_user :: firstname_toString(void)
{
    std::ostringstream out;
    out << "\"" << firstname << "\"";
    return out.str();
}
std::string
SQL_TABLE_user :: lastname_toString(void)
{
    std::ostringstream out;
    out << "\"" << lastname << "\"";
    return out.str();
}
std::string
SQL_TABLE_user :: mi_toString(void)
{
    std::ostringstream out;
    out << "\"" << mi << "\"";
    return out.str();
}
std::string
SQL_TABLE_user :: SSN_toString(void)
{
    std::ostringstream out;
    out << SSN;
    return out.str();
}
std::string
SQL_TABLE_user :: balance_toString(void)
{
    std::ostringstream out;
    out << balance;
    return out.str();
}
std::string
SQL_TABLE_user :: proto_toString(void)
{
    std::ostringstream out;
    out << "BLOB:";
    for (size_t ind = 0; ind < proto.size(); ind++)
    {
        uint8_t b = (uint8_t) proto[ind];
        out << std::hex << std::setw(2) << (int) b;
    }
    return out.str();
}
std::string
SQL_TABLE_user :: test2_toString(void)
{
    return test2 ? "true" : "false";
}
std::string
SQL_TABLE_user :: test3_toString(void)
{
    return sample::library2::EnumField_t_Name(test3);
}
std::string
SQL_TABLE_user :: checkouts_toString(void)
{
    std::ostringstream out;
    bool first = true;
    for (size_t ind = 0; ind < checkouts.size(); ind++)
    {
        if (!first)
            out << ",";
        out << "{";
        out << checkouts[ind].toString();
        out << "}";
        first = false;
    }
    return out.str();
}


std::string SQL_TABLE_user :: toString(void)
{
    std::ostringstream out;
    out << "rowid:" << rowid_toString() << ";";
    out << "userid: " << userid_toString() << "; ";
    out << "firstname: " << firstname_toString() << "; ";
    out << "lastname: " << lastname_toString() << "; ";
    out << "mi: " << mi_toString() << "; ";
    out << "SSN: " << SSN_toString() << "; ";
    out << "balance: " << balance_toString() << "; ";
    out << "proto: " << proto_toString() << "; ";
    out << "test2: " << test2_toString() << "; ";
    out << "test3: " << test3_toString() << "; ";
    out << "checkouts: " << checkouts_toString() << "; ";

    return out.str();
}

void SQL_TABLE_user :: set_db(sqlite3 *_pdb)
{
    finalize();
    pdb = _pdb;
// set_db for subtable checkouts 2
    for (size_t ind = 0; ind < checkouts.size(); ind++)
    {
        SQL_TABLE_checkouts &row = checkouts[ind];
        row.set_db(_pdb);
    }

}

bool SQL_TABLE_user :: get_columns(sqlite3_stmt * pStmt)
{
    int got;
    if (log_row_func)
        log_row_msg.str("user: ");

    rowid = sqlite3_column_int64(pStmt, 0);
    if (log_row_func)
        log_row_msg << "rowid:" << rowid << "; ";

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (userid) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    userid = sqlite3_column_int(pStmt, 1);
    if (log_row_func)
        log_row_msg << "userid:" << userid << "; ";
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (firstname) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        firstname.clear();
        firstname.resize(len);
        memcpy((void*)firstname.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "firstname:\"" << firstname << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "firstname:(" << firstname.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (lastname) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 3);
        int len = sqlite3_column_bytes(pStmt, 3);
        lastname.clear();
        lastname.resize(len);
        memcpy((void*)lastname.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "lastname:\"" << lastname << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "lastname:(" << lastname.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (mi) : "
                "column 4 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 4);
        int len = sqlite3_column_bytes(pStmt, 4);
        mi.clear();
        mi.resize(len);
        memcpy((void*)mi.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "mi:\"" << mi << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "mi:(" << mi.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (SSN) : "
                "column 5 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    SSN = sqlite3_column_int(pStmt, 5);
    if (log_row_func)
        log_row_msg << "SSN:" << SSN << "; ";
    got = sqlite3_column_type(pStmt, 6);
    if (got != SQLITE_FLOAT)
    {
        PRINT_ERR("get_columns (balance) : "
                "column 6 wrong type (%d %d)",
                got, SQLITE_FLOAT);
        return false;
    }
    balance = sqlite3_column_double(pStmt, 6);
    if (log_row_func)
        log_row_msg << "balance:" << balance << "; ";
    got = sqlite3_column_type(pStmt, 7);
    if (got != SQLITE_BLOB)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (proto) : "
                "column 7 wrong type (%d %d)",
                got, SQLITE_BLOB);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_blob(
            pStmt, 7);
        int len = sqlite3_column_bytes(pStmt, 7);
        proto.clear();
        proto.resize(len);
        memcpy((void*)proto.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "proto:\"" << proto << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "proto:(" << proto.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 8);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (test2) : "
                "column 8 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sqlite3_column_int(pStmt, 8))
        test2 = true;
    else
        test2 = false;
    if (log_row_func)
        log_row_msg << "test2:"
                    << (test2 ? "true" : "false") << "; ";
    got = sqlite3_column_type(pStmt, 9);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (test3) : "
                "column 9 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sample::library2::EnumField_t_IsValid(test3))
        test3 = (sample::library2::EnumField_t) sqlite3_column_int(
            pStmt, 9);
    else
        test3 = sample::library2::ENUM_TWO;

    if (log_row_func)
        log_row_msg << "test3:"
                    << sample::library2::EnumField_t_Name(test3) << "; ";


    if (log_row_func)
    {
        log_row_func(log_arg, log_row_msg.str());
        log_row_msg.str("");
    }

    return true;
}

bool SQL_TABLE_user :: get_by_userid(int32_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_userid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE userid = ?",
            -1, &pStmt_by_userid, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_userid);

    r = sqlite3_bind_int(pStmt_by_userid, 1, v);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_userid);

    r = sqlite3_step(pStmt_by_userid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_userid);
        previous_get = pStmt_by_userid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_SSN(int32_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_SSN == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE SSN = ?",
            -1, &pStmt_by_SSN, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_SSN);

    r = sqlite3_bind_int(pStmt_by_SSN, 1, v);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_SSN);

    r = sqlite3_step(pStmt_by_SSN);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_SSN);
        previous_get = pStmt_by_SSN;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_test2(bool v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_test2 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE test2 = ?",
            -1, &pStmt_by_test2, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_test2);

    r = sqlite3_bind_int(pStmt_by_test2, 1,
                             v ? 1 : 0);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_test2);

    r = sqlite3_step(pStmt_by_test2);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_test2);
        previous_get = pStmt_by_test2;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_test3(sample::library2::EnumField_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_test3 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE test3 = ?",
            -1, &pStmt_by_test3, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_test3);

    r = sqlite3_bind_int(pStmt_by_test3, 1, v);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_test3);

    r = sqlite3_step(pStmt_by_test3);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_test3);
        previous_get = pStmt_by_test3;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: get_by_lastname_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_by_lastname_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE lastname like ?",
            -1, &pStmt_by_lastname_like, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT LIKE for lastname",
                      r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_lastname_like);

    r = sqlite3_bind_text(pStmt_by_lastname_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_lastname_like);

    r = sqlite3_step(pStmt_by_lastname_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_lastname_like);
        previous_get = pStmt_by_lastname_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


bool SQL_TABLE_user :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO user "
            "(firstname, lastname, mi, SSN, balance, proto, test2, test3) "
            "values (?,?,?,?,?,?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
	    const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing INSERT", r, msg);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_text(pStmt_insert, 1,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind firstname: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind lastname: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 3,
         mi.c_str(), mi.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind mi: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 4,
                             SSN);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind SSN: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_double(pStmt_insert, 5,
                             balance);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind balance: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_blob(pStmt_insert, 6,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind proto: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 7,
                             test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind test2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 8,
                             (int) test3);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind test3: r = %d (%s)", r, msg);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: r = %d (%s)", r, msg);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);
    userid = rowid;

    return true;
}

bool SQL_TABLE_user :: insert_force(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT (force) before set_db");
        return false;
    }

    if (pStmt_insert_force == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT OR REPLACE INTO user "
            "(userid, firstname, lastname, mi, SSN, balance, proto, test2, test3) "
            "values (?,?,?,?,?,?,?,?,?)",
            -1, &pStmt_insert_force, NULL);
        if (r != SQLITE_OK)
        {
	    const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing INSERT (force)", r, msg);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert_force);

    r = sqlite3_bind_int(pStmt_insert_force, 1,
                             userid);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind userid: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert_force, 2,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind firstname: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert_force, 3,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind lastname: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert_force, 4,
         mi.c_str(), mi.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind mi: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert_force, 5,
                             SSN);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind SSN: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_double(pStmt_insert_force, 6,
                             balance);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind balance: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_blob(pStmt_insert_force, 7,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind proto: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert_force, 8,
                             test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind test2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert_force, 9,
                             (int) test3);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind test3: r = %d (%s)", r, msg);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert_force);

    r = sqlite3_step(pStmt_insert_force);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: r = %d (%s)", r, msg);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_user :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE user SET "
            "(firstname, lastname, mi, SSN, balance, proto, test2, test3) "
            "= (?,?,?,?,?,?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing UPDATE", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_text(pStmt_update, 1,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind firstname: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 2,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind lastname: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 3,
         mi.c_str(), mi.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind mi: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 4,
                             SSN);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind SSN: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_double(pStmt_update, 5,
                             balance);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind balance: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_blob(pStmt_update, 6,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind proto: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 7,
                             test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind test2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 8,
                             (int) test3);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind test3: r = %d (%s)", r, msg);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update,
                           9, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: r = %d (%s)", r, msg);
        return false;
    }

    return true;
}

bool SQL_TABLE_user :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM user WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing DELETE", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("delete: r = %d (%s)", r, msg);
        return false;
    }

    return true;
}

bool SQL_TABLE_user :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for get_by_rowid",
                      r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for get_all", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

int SQL_TABLE_user :: get_subtable_checkouts(void)
{
    SQL_TABLE_checkouts  row(pdb);
    bool status;
    int count = 0;

    checkouts.clear();
    status = row.get_by_userid2(userid);
    while (status)
    {
        // note this uses the special table class
        // copy constructor that only copies the data,
        // not the prepared statements.
        checkouts.push_back(row);
        count++;
        status = row.get_next();
    }

    return count;
}

bool SQL_TABLE_user :: insert_subtable_checkouts(void)
{
    for (size_t ind = 0; ind < checkouts.size(); ind++)
    {
        SQL_TABLE_checkouts &row = checkouts[ind];
        row.insert();
    }
    return true;
}

bool SQL_TABLE_user :: insert_subtable_checkouts_force(void)
{
    for (size_t ind = 0; ind < checkouts.size(); ind++)
    {
        SQL_TABLE_checkouts &row = checkouts[ind];
        row.insert_force();
    }
    return true;
}


void SQL_TABLE_user :: get_subtables(void)
{
    get_subtable_checkouts();

}

void SQL_TABLE_user :: insert_subtables(void)
{
    insert_subtable_checkouts();

}

void SQL_TABLE_user :: insert_subtables_force(void)
{
    insert_subtable_checkouts_force();

}

bool SQL_TABLE_user :: get_great_balance(double v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_great_balance == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE balance > ?",
            -1, &pStmt_get_great_balance, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for "
                   "CUSTOM-GET great_balance", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_great_balance);

    r = sqlite3_bind_double(pStmt_get_great_balance,
                             1, v1);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_great_balance);

    r = sqlite3_step(pStmt_get_great_balance);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_great_balance);
        previous_get = pStmt_get_great_balance;
        ret = true;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_founders(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_founders == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE userid < 100",
            -1, &pStmt_get_founders, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for "
                   "CUSTOM-GET founders", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_founders);



    if (log_get_func)
        log_get_func(log_arg, pStmt_get_founders);

    r = sqlite3_step(pStmt_get_founders);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_founders);
        previous_get = pStmt_get_founders;
        ret = true;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_firstlast(const std::string & v1, const std::string & v2)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_firstlast == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE firstname LIKE ? AND lastname LIKE ?",
            -1, &pStmt_get_firstlast, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for "
                   "CUSTOM-GET firstlast", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_firstlast);

    r = sqlite3_bind_text(pStmt_get_firstlast, 1, 
                          v1.c_str(), v1.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_get_firstlast, 2, 
                          v2.c_str(), v2.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_firstlast);

    r = sqlite3_step(pStmt_get_firstlast);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_firstlast);
        previous_get = pStmt_get_firstlast;
        ret = true;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: update_balance(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_balance == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (balance) = "
            "(?) WHERE rowid = ?",
            -1, &pStmt_update_balance, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing CUSTOM-UPD "
                   "balance", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_balance);

    r = sqlite3_bind_double(pStmt_update_balance,
                             1, balance);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind balance: r = %d (%s)", r, msg);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_balance,
                           2, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_balance);

    r = sqlite3_step(pStmt_update_balance);
    if (r == SQLITE_DONE)
        ret = true;
    else
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update balance: r = %d (%s)", r, msg);
        return false;
    }

    return ret;
}
bool SQL_TABLE_user :: update_firstlast(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_firstlast == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (firstname, lastname) = "
            "(?,?) WHERE rowid = ?",
            -1, &pStmt_update_firstlast, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing CUSTOM-UPD "
                   "firstlast", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_firstlast);

    r = sqlite3_bind_text(
        pStmt_update_firstlast, 1,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind firstname: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(
        pStmt_update_firstlast, 2,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind lastname: r = %d (%s)", r, msg);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_firstlast,
                           3, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_firstlast);

    r = sqlite3_step(pStmt_update_firstlast);
    if (r == SQLITE_DONE)
        ret = true;
    else
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update firstlast: r = %d (%s)", r, msg);
        return false;
    }

    return ret;
}
bool SQL_TABLE_user :: update_by_userid_stuff(int32_t v1, const std::string & v2)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_by_userid_stuff == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (proto, test2, test3, balance) = "
            "(?,?,?,?) WHERE userid = ? and lastname = ?",
            -1, &pStmt_update_by_userid_stuff, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing CUSTOM-UPDBY "
                      "userid_stuff", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_by_userid_stuff);

    r = sqlite3_bind_blob(
        pStmt_update_by_userid_stuff, 1,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind proto: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update_by_userid_stuff,
                             2, test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind test2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update_by_userid_stuff,
                             3, (int) test3);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind test3: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_double(pStmt_update_by_userid_stuff,
                             4, balance);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind balance: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update_by_userid_stuff,
                             5, v1);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind field 1: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update_by_userid_stuff, 6,
                          v2.c_str(), v2.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind field 2: r = %d (%s)", r, msg);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_by_userid_stuff);

    r = sqlite3_step(pStmt_update_by_userid_stuff);
    if (r == SQLITE_DONE)
        ret = true;
    else
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update userid_stuff: r = %d (%s)", r, msg);
        return false;
    }

    return ret;
}

bool SQL_TABLE_user :: delete_SSN(int32_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if(pStmt_del_SSN == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "DELETE FROM user WHERE ssn = ?",
            -1, &pStmt_del_SSN, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing CUSTOM-DEL", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_del_SSN);

    r = sqlite3_bind_int(pStmt_del_SSN,
                             1, v1);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind arg 1: r = %d (%s)", r, msg);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_del_SSN);

    r = sqlite3_step(pStmt_del_SSN);
    if (r == SQLITE_DONE)
        ret = true;
    else
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("delete SSN: r = %d (%s)", r, msg);
        return false;
    }

    return ret;
}

#ifdef INCLUDE_SQLITE3GEN_PROTOBUF_SUPPORT
void
SQL_TABLE_user :: copy_to_proto(
              library::TABLE_user_m &msg)
{
    msg.set_schema_version(TABLE_VERSION);
    msg.set_userid(userid);
    msg.set_firstname(firstname);
    msg.set_lastname(lastname);
    msg.set_mi(mi);
    msg.set_ssn(SSN);
    msg.set_balance(balance);
    msg.set_proto(proto);
    msg.set_test2(test2 ? true : false);
    if (!sample::library2::EnumField_t_IsValid(test3))
        test3 = sample::library2::ENUM_TWO;

    msg.set_test3(test3);
    msg.clear_checkouts();
    for (size_t ind = 0; ind < checkouts.size(); ind++)
        checkouts[ind].copy_to_proto(*msg.add_checkouts());

}

void
SQL_TABLE_user :: copy_from_proto(
              const library::TABLE_user_m &msg)
{
    if (msg.has_schema_version() && msg.schema_version() != TABLE_VERSION)
    {
        // NOTE : if this becomes a problem in the future, we could
        //        enhance sql3gen to allow the user to register a
        //        callback function which can convert a message from
        //        one schema version to another.
        std::ostringstream err;
        err << "SQL_TABLE_user :: "
            << "copy_from_proto : recvd protobuf message with "
            << "schema version " << msg.schema_version()
            << " (supported is " << TABLE_VERSION
            << ")\n";
        if (err_log_func)
            err_log_func(log_arg, err.str());
        else
            std::cerr << err.str();
    }
    if (msg.has_userid())
        userid = msg.userid();
    else
        userid = -1;

    if (msg.has_firstname())
        firstname = msg.firstname();
    else
        firstname = "";

    if (msg.has_lastname())
        lastname = msg.lastname();
    else
        lastname = "";

    if (msg.has_mi())
        mi = msg.mi();
    else
        mi = "";

    if (msg.has_ssn())
        SSN = msg.ssn();
    else
        SSN = 0;

    if (msg.has_balance())
        balance = msg.balance();
    else
        balance = 0;

    if (msg.has_proto())
        proto = msg.proto();
    else
        proto.clear();

    if (msg.has_test2())
        test2 = msg.test2() ? true : false;
    else
        test2 = false;

    if (msg.has_test3())
        test3 = msg.test3();
    else
        test3 = sample::library2::ENUM_TWO;

    checkouts.clear();
    checkouts.resize(msg.checkouts_size());
    for (int ind = 0; ind < msg.checkouts_size(); ind++)
    {
        checkouts[ind].set_db(pdb);
        checkouts[ind].copy_from_proto(msg.checkouts(ind));
    }

}

#endif
#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
void
SQL_TABLE_user :: copy_to_xml(tinyxml2::XMLElement *el)
{
    el->SetValue("user");
    el->SetAttribute("type", "row");
    el->SetAttribute("rowid", (int64_t) rowid);

    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("userid");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << userid;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("firstname");
        child->SetAttribute("type", "text");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(firstname.c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("lastname");
        child->SetAttribute("type", "text");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(lastname.c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("mi");
        child->SetAttribute("type", "text");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(mi.c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("SSN");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << SSN;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("balance");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << balance;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("proto");
        child->SetAttribute("type", "blob");
        el->InsertEndChild(child);
        std::string hex;
        blob_to_hex(hex, proto);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(hex.c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("test2");
        child->SetAttribute("type", "bool");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(test2 ? "true" : "false");
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("test3");
        child->SetAttribute("type", "sample::library2::EnumField_t");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(
                sample::library2::EnumField_t_Name(test3).c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("checkouts");
        child->SetAttribute("type", "subtable");
        el->InsertEndChild(child);
        for (size_t ind = 0; ind < checkouts.size(); ind++)
        {
            tinyxml2::XMLElement * child2 =
                el->GetDocument()->NewElement("checkouts");
            child2->SetAttribute("type", "subtable_row");
            child2->SetAttribute("index", (int) ind);
            child->InsertEndChild(child2);
            SQL_TABLE_checkouts &f = checkouts[ind];
            f.copy_to_xml(child2);
        }
    }

}

bool
SQL_TABLE_user :: xml_decoder_userid(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> userid;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}
bool
SQL_TABLE_user :: xml_decoder_firstname(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    firstname = "";
    if (n)
    {
        const char * v = n->Value();
        if (v)
            firstname = v;
    }
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_lastname(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    lastname = "";
    if (n)
    {
        const char * v = n->Value();
        if (v)
            lastname = v;
    }
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_mi(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    mi = "";
    if (n)
    {
        const char * v = n->Value();
        if (v)
            mi = v;
    }
    return true;
}
bool
SQL_TABLE_user :: xml_decoder_SSN(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> SSN;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}
bool
SQL_TABLE_user :: xml_decoder_balance(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> balance;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}
bool
SQL_TABLE_user :: xml_decoder_proto(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
            hex_to_blob(proto, v);
        else
            proto = "";
        return true;
    }
    return false;
}
bool
SQL_TABLE_user :: xml_decoder_test2(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            if (strcmp(v, "true") == 0)
                test2 = true;
            else if (strcmp(v, "false") == 0)
                test2 = false;
            else
                return false;
        }
        return true;
    }
    return false;
}
bool
SQL_TABLE_user :: xml_decoder_test3(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
            return sample::library2::EnumField_t_Parse(v, &test3);
        return true;
    }
    return false;
}
bool
SQL_TABLE_user :: xml_decoder_checkouts(const tinyxml2::XMLElement *el)
{
    SQL_TABLE_checkouts  row(pdb);

    if (strcmp(el->Value(), "checkouts") != 0)
        return false;

    const tinyxml2::XMLElement *child = el->FirstChildElement();
    while (child)
    {
        if (row.copy_from_xml(child) == false)
            return false;
        checkouts.push_back(row);
        child = child->NextSiblingElement();
    }

    return true;
}


bool
SQL_TABLE_user :: copy_from_xml(const tinyxml2::XMLElement *el)
{
    init();
    if (xml_decoders_initialized == false)
    {
        xml_decoders["userid"] =
            &SQL_TABLE_user::xml_decoder_userid;
        xml_decoders["firstname"] =
            &SQL_TABLE_user::xml_decoder_firstname;
        xml_decoders["lastname"] =
            &SQL_TABLE_user::xml_decoder_lastname;
        xml_decoders["mi"] =
            &SQL_TABLE_user::xml_decoder_mi;
        xml_decoders["SSN"] =
            &SQL_TABLE_user::xml_decoder_SSN;
        xml_decoders["balance"] =
            &SQL_TABLE_user::xml_decoder_balance;
        xml_decoders["proto"] =
            &SQL_TABLE_user::xml_decoder_proto;
        xml_decoders["test2"] =
            &SQL_TABLE_user::xml_decoder_test2;
        xml_decoders["test3"] =
            &SQL_TABLE_user::xml_decoder_test3;
        xml_decoders["checkouts"] =
            &SQL_TABLE_user::xml_decoder_checkouts;

        xml_decoders_initialized = true;
    }
    if (strcmp(el->Value(), "user") != 0)
    {
        if (err_log_func)
        {
            std::ostringstream err;
            err << "SQL_TABLE_user :: "
                << "copy_from_xml : node name is " << el->Value()
                << " not 'user'!\n";
            err_log_func(log_arg, err.str().c_str());
        }
        return false;
    }
    const tinyxml2::XMLElement * child = el->FirstChildElement();
    while (child)
    {
        const char * v = child->Value();
        if (v && v[0] != 0)
        {
            xml_decoder_map_t::iterator it = xml_decoders.find(v);
            if (it != xml_decoders.end())
            {
                xml_decoder_func_t f = it->second;
                if ((this->*f)(child) == false)
                    return false;
            }
        }
        child = child->NextSiblingElement();
    }
    return true;
}

#endif

//static
bool SQL_TABLE_user :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"user\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("select from tables: %d (%s)", r, msg);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"user\",19)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "user", v, 19);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (19) "
            "WHERE name = \"user\"",
            NULL, NULL, NULL);
    }
    else
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("select from tables / step r = %d (%s)", r, msg);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_user :: table_create(sqlite3 *pdb)
{
    std::ostringstream  e;
    char * errmsg = NULL;
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    errmsg = NULL;
    r = sqlite3_exec(pdb, "CREATE TABLE user "
        "(userid integer PRIMARY KEY AUTOINCREMENT, firstname text, lastname text, mi text, SSN integer, balance double, proto blob, test2 integer, test3 integer, CONSTRAINT user_constraint1 UNIQUE (firstname, lastname) CONSTRAINT user_constraint2 UNIQUE (mi, SSN))",
        NULL, NULL, &errmsg);

    printf("CREATE TABLE: CREATE TABLE user "
           "(userid integer PRIMARY KEY AUTOINCREMENT, firstname text, lastname text, mi text, SSN integer, balance double, proto blob, test2 integer, test3 integer, CONSTRAINT user_constraint1 UNIQUE (firstname, lastname) CONSTRAINT user_constraint2 UNIQUE (mi, SSN))\n");

    if (r != SQLITE_OK)
    {
        e << "CREATE TABLE returned r = " << r
          << " error '" << errmsg << "'\n";
        printf("SQL ERROR: %s\n", e.str().c_str());
    	if (errmsg != NULL)
            sqlite3_free(errmsg);
        if (err_log_func)
            err_log_func(log_arg, e.str());
        return false;
    }

    errmsg = NULL;
    r = sqlite3_exec(pdb,"CREATE INDEX user_userid "
                 "ON user (userid)",
        NULL, NULL, &errmsg);
    printf("CREATE INDEX: CREATE INDEX user_userid "
           "ON user (userid)\n");
    if (r != SQLITE_OK)
    {
        e << "CREATE INDEX returned r = " << r
          << " error '" << errmsg << "'\n";
        printf("SQL ERROR: %s\n", e.str().c_str());
        if (errmsg != NULL)
            sqlite3_free(errmsg);
        if (err_log_func)
            err_log_func(log_arg, e.str());
        return false;
    }
    errmsg = NULL;
    r = sqlite3_exec(pdb,"CREATE INDEX user_SSN "
                 "ON user (SSN)",
        NULL, NULL, &errmsg);
    printf("CREATE INDEX: CREATE INDEX user_SSN "
           "ON user (SSN)\n");
    if (r != SQLITE_OK)
    {
        e << "CREATE INDEX returned r = " << r
          << " error '" << errmsg << "'\n";
        printf("SQL ERROR: %s\n", e.str().c_str());
        if (errmsg != NULL)
            sqlite3_free(errmsg);
        if (err_log_func)
            err_log_func(log_arg, e.str());
        return false;
    }


    return true;
}

//static
void SQL_TABLE_user :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE user",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE user\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}

#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
//static
void SQL_TABLE_user :: export_xml(sqlite3 *pdb,
                                           tinyxml2::XMLElement *el)
{
    SQL_TABLE_user row(pdb);

    bool ok = row.get_all();
    while (ok)
    {
        row.get_subtables();
        tinyxml2::XMLElement * row_el =
            el->GetDocument()->NewElement("user");
        row.copy_to_xml(row_el);
        el->InsertEndChild(row_el);
        ok = row.get_next();
    }
}

//static
bool SQL_TABLE_user :: import_xml(sqlite3 *pdb,
                                           tinyxml2::XMLElement *el)
{
    tinyxml2::XMLElement * row_el;
    SQL_TABLE_user  row(pdb);

    for (row_el = el->FirstChildElement(); row_el;
         row_el = row_el->NextSiblingElement())
    {
        row.copy_from_xml(row_el);
        // use insert_force because the xml may include AUTOINCR
        // values which must be set the hard way.
        row.insert_force();
        row.insert_subtables_force();
    }

    return true;
}
#endif

SQL_TABLE_book :: SQL_TABLE_book(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
    xml_decoders_initialized = false;
#endif
}

// copy constructor, duplicates all the data fields (including rowid)
// but does not duplicate the statement pointers, because then they'd
// get double-freed.
SQL_TABLE_book :: SQL_TABLE_book(
    const SQL_TABLE_book &other)
{
    init_statements();
    operator=(other);
}

void
SQL_TABLE_book :: operator=(const SQL_TABLE_book &other)
{
    pdb = other.pdb;
    rowid = other.rowid;
    bookid = other.bookid;
    title = other.title;
    isbn = other.isbn;
    price = other.price;
    quantity = other.quantity;

}

void
SQL_TABLE_book :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_insert_force = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

    pStmt_by_bookid = NULL;
    pStmt_by_isbn = NULL;

    pStmt_by_title_like = NULL;

    pStmt_get_out_of_stock = NULL;

    pStmt_update_quantity = NULL;
    pStmt_update_price = NULL;



    previous_get = NULL;
    init();
}

SQL_TABLE_book :: ~SQL_TABLE_book(void)
{
    finalize();
}

void
SQL_TABLE_book :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_insert_force)
        sqlite3_finalize(pStmt_insert_force);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

    if (pStmt_by_bookid)
        sqlite3_finalize(pStmt_by_bookid);
    if (pStmt_by_isbn)
        sqlite3_finalize(pStmt_by_isbn);

    if (pStmt_by_title_like)
        sqlite3_finalize(pStmt_by_title_like);

    if (pStmt_get_out_of_stock)
        sqlite3_finalize(pStmt_get_out_of_stock);

    if (pStmt_update_quantity)
        sqlite3_finalize(pStmt_update_quantity);
    if (pStmt_update_price)
        sqlite3_finalize(pStmt_update_price);



    init_statements();
}

void SQL_TABLE_book :: init(void)
{
    rowid = -1;
    bookid = 0;
    title = "";
    isbn = "";
    price = 0;
    quantity = 0;

    previous_get = NULL;
}

//static
void SQL_TABLE_book :: get_column_descriptors(
    std::vector<SQL_Column_Descriptor> &columns)
{
    SQL_Column_Descriptor desc;
    columns.clear();

    desc.tablename = "book";
    desc.fieldname = "bookid";
    desc.ctype = "int32_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT;
    columns.push_back(desc);

    desc.tablename = "book";
    desc.fieldname = "title";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "book";
    desc.fieldname = "isbn";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "book";
    desc.fieldname = "price";
    desc.ctype = "double";
    desc.sqlite_type = SQLITE_FLOAT;
    desc.sqlite3gen_type = TYPE_DOUBLE;
    columns.push_back(desc);

    desc.tablename = "book";
    desc.fieldname = "quantity";
    desc.ctype = "int32_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT;
    columns.push_back(desc);

}

std::string SQL_TABLE_book :: rowid_toString(void)
{
    std::ostringstream out;
    out << rowid;
    return out.str();
}

std::string
SQL_TABLE_book :: bookid_toString(void)
{
    std::ostringstream out;
    out << bookid;
    return out.str();
}
std::string
SQL_TABLE_book :: title_toString(void)
{
    std::ostringstream out;
    out << "\"" << title << "\"";
    return out.str();
}
std::string
SQL_TABLE_book :: isbn_toString(void)
{
    std::ostringstream out;
    out << "\"" << isbn << "\"";
    return out.str();
}
std::string
SQL_TABLE_book :: price_toString(void)
{
    std::ostringstream out;
    out << price;
    return out.str();
}
std::string
SQL_TABLE_book :: quantity_toString(void)
{
    std::ostringstream out;
    out << quantity;
    return out.str();
}


std::string SQL_TABLE_book :: toString(void)
{
    std::ostringstream out;
    out << "rowid:" << rowid_toString() << ";";
    out << "bookid: " << bookid_toString() << "; ";
    out << "title: " << title_toString() << "; ";
    out << "isbn: " << isbn_toString() << "; ";
    out << "price: " << price_toString() << "; ";
    out << "quantity: " << quantity_toString() << "; ";

    return out.str();
}

void SQL_TABLE_book :: set_db(sqlite3 *_pdb)
{
    finalize();
    pdb = _pdb;

}

bool SQL_TABLE_book :: get_columns(sqlite3_stmt * pStmt)
{
    int got;
    if (log_row_func)
        log_row_msg.str("book: ");

    rowid = sqlite3_column_int64(pStmt, 0);
    if (log_row_func)
        log_row_msg << "rowid:" << rowid << "; ";

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (bookid) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    bookid = sqlite3_column_int(pStmt, 1);
    if (log_row_func)
        log_row_msg << "bookid:" << bookid << "; ";
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (title) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        title.clear();
        title.resize(len);
        memcpy((void*)title.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "title:\"" << title << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "title:(" << title.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (isbn) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 3);
        int len = sqlite3_column_bytes(pStmt, 3);
        isbn.clear();
        isbn.resize(len);
        memcpy((void*)isbn.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "isbn:\"" << isbn << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "isbn:(" << isbn.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_FLOAT)
    {
        PRINT_ERR("get_columns (price) : "
                "column 4 wrong type (%d %d)",
                got, SQLITE_FLOAT);
        return false;
    }
    price = sqlite3_column_double(pStmt, 4);
    if (log_row_func)
        log_row_msg << "price:" << price << "; ";
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (quantity) : "
                "column 5 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    quantity = sqlite3_column_int(pStmt, 5);
    if (log_row_func)
        log_row_msg << "quantity:" << quantity << "; ";


    if (log_row_func)
    {
        log_row_func(log_arg, log_row_msg.str());
        log_row_msg.str("");
    }

    return true;
}

bool SQL_TABLE_book :: get_by_bookid(int32_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_bookid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book WHERE bookid = ?",
            -1, &pStmt_by_bookid, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_bookid);

    r = sqlite3_bind_int(pStmt_by_bookid, 1, v);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_bookid);

    r = sqlite3_step(pStmt_by_bookid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_bookid);
        previous_get = pStmt_by_bookid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_book :: get_by_isbn(const std::string & v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_isbn == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book WHERE isbn = ?",
            -1, &pStmt_by_isbn, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_isbn);

    r = sqlite3_bind_text(pStmt_by_isbn, 1,
         v.c_str(), v.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_isbn);

    r = sqlite3_step(pStmt_by_isbn);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_isbn);
        previous_get = pStmt_by_isbn;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: get_by_title_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_by_title_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book "
            "WHERE title like ?",
            -1, &pStmt_by_title_like, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT LIKE for title",
                      r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_title_like);

    r = sqlite3_bind_text(pStmt_by_title_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_title_like);

    r = sqlite3_step(pStmt_by_title_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_title_like);
        previous_get = pStmt_by_title_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


bool SQL_TABLE_book :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO book "
            "(title, isbn, price, quantity) "
            "values (?,?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
	    const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing INSERT", r, msg);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_text(pStmt_insert, 1,
         title.c_str(), title.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind title: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         isbn.c_str(), isbn.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind isbn: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_double(pStmt_insert, 3,
                             price);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind price: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 4,
                             quantity);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind quantity: r = %d (%s)", r, msg);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: r = %d (%s)", r, msg);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);
    bookid = rowid;

    return true;
}

bool SQL_TABLE_book :: insert_force(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT (force) before set_db");
        return false;
    }

    if (pStmt_insert_force == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT OR REPLACE INTO book "
            "(bookid, title, isbn, price, quantity) "
            "values (?,?,?,?,?)",
            -1, &pStmt_insert_force, NULL);
        if (r != SQLITE_OK)
        {
	    const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing INSERT (force)", r, msg);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert_force);

    r = sqlite3_bind_int(pStmt_insert_force, 1,
                             bookid);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind bookid: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert_force, 2,
         title.c_str(), title.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind title: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert_force, 3,
         isbn.c_str(), isbn.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind isbn: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_double(pStmt_insert_force, 4,
                             price);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind price: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert_force, 5,
                             quantity);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind quantity: r = %d (%s)", r, msg);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert_force);

    r = sqlite3_step(pStmt_insert_force);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: r = %d (%s)", r, msg);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_book :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE book SET "
            "(title, isbn, price, quantity) "
            "= (?,?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing UPDATE", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_text(pStmt_update, 1,
         title.c_str(), title.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind title: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 2,
         isbn.c_str(), isbn.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind isbn: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_double(pStmt_update, 3,
                             price);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind price: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 4,
                             quantity);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind quantity: r = %d (%s)", r, msg);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update,
                           5, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: r = %d (%s)", r, msg);
        return false;
    }

    return true;
}

bool SQL_TABLE_book :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM book WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing DELETE", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("delete: r = %d (%s)", r, msg);
        return false;
    }

    return true;
}

bool SQL_TABLE_book :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for get_by_rowid",
                      r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for get_all", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}



void SQL_TABLE_book :: get_subtables(void)
{

}

void SQL_TABLE_book :: insert_subtables(void)
{

}

void SQL_TABLE_book :: insert_subtables_force(void)
{

}

bool SQL_TABLE_book :: get_out_of_stock(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_out_of_stock == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book "
            "WHERE quantity == 0",
            -1, &pStmt_get_out_of_stock, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for "
                   "CUSTOM-GET out_of_stock", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_out_of_stock);



    if (log_get_func)
        log_get_func(log_arg, pStmt_get_out_of_stock);

    r = sqlite3_step(pStmt_get_out_of_stock);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_out_of_stock);
        previous_get = pStmt_get_out_of_stock;
        ret = true;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: update_quantity(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_quantity == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE book SET (quantity) = "
            "(?) WHERE rowid = ?",
            -1, &pStmt_update_quantity, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing CUSTOM-UPD "
                   "quantity", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_quantity);

    r = sqlite3_bind_int(pStmt_update_quantity,
                             1, quantity);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind quantity: r = %d (%s)", r, msg);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_quantity,
                           2, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_quantity);

    r = sqlite3_step(pStmt_update_quantity);
    if (r == SQLITE_DONE)
        ret = true;
    else
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update quantity: r = %d (%s)", r, msg);
        return false;
    }

    return ret;
}
bool SQL_TABLE_book :: update_price(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_price == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE book SET (price) = "
            "(?) WHERE rowid = ?",
            -1, &pStmt_update_price, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing CUSTOM-UPD "
                   "price", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_price);

    r = sqlite3_bind_double(pStmt_update_price,
                             1, price);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind price: r = %d (%s)", r, msg);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_price,
                           2, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_price);

    r = sqlite3_step(pStmt_update_price);
    if (r == SQLITE_DONE)
        ret = true;
    else
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update price: r = %d (%s)", r, msg);
        return false;
    }

    return ret;
}


#ifdef INCLUDE_SQLITE3GEN_PROTOBUF_SUPPORT
void
SQL_TABLE_book :: copy_to_proto(
              library::TABLE_book_m &msg)
{
    msg.set_schema_version(TABLE_VERSION);
    msg.set_bookid(bookid);
    msg.set_title(title);
    msg.set_isbn(isbn);
    msg.set_price(price);
    msg.set_quantity(quantity);

}

void
SQL_TABLE_book :: copy_from_proto(
              const library::TABLE_book_m &msg)
{
    if (msg.has_schema_version() && msg.schema_version() != TABLE_VERSION)
    {
        // NOTE : if this becomes a problem in the future, we could
        //        enhance sql3gen to allow the user to register a
        //        callback function which can convert a message from
        //        one schema version to another.
        std::ostringstream err;
        err << "SQL_TABLE_book :: "
            << "copy_from_proto : recvd protobuf message with "
            << "schema version " << msg.schema_version()
            << " (supported is " << TABLE_VERSION
            << ")\n";
        if (err_log_func)
            err_log_func(log_arg, err.str());
        else
            std::cerr << err.str();
    }
    if (msg.has_bookid())
        bookid = msg.bookid();
    else
        bookid = 0;

    if (msg.has_title())
        title = msg.title();
    else
        title = "";

    if (msg.has_isbn())
        isbn = msg.isbn();
    else
        isbn = "";

    if (msg.has_price())
        price = msg.price();
    else
        price = 0;

    if (msg.has_quantity())
        quantity = msg.quantity();
    else
        quantity = 0;


}

#endif
#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
void
SQL_TABLE_book :: copy_to_xml(tinyxml2::XMLElement *el)
{
    el->SetValue("book");
    el->SetAttribute("type", "row");
    el->SetAttribute("rowid", (int64_t) rowid);

    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("bookid");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << bookid;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("title");
        child->SetAttribute("type", "text");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(title.c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("isbn");
        child->SetAttribute("type", "text");
        el->InsertEndChild(child);
        tinyxml2::XMLText * v =
            el->GetDocument()->NewText(isbn.c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("price");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << price;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("quantity");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << quantity;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }

}

bool
SQL_TABLE_book :: xml_decoder_bookid(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> bookid;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}
bool
SQL_TABLE_book :: xml_decoder_title(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    title = "";
    if (n)
    {
        const char * v = n->Value();
        if (v)
            title = v;
    }
    return true;
}
bool
SQL_TABLE_book :: xml_decoder_isbn(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    isbn = "";
    if (n)
    {
        const char * v = n->Value();
        if (v)
            isbn = v;
    }
    return true;
}
bool
SQL_TABLE_book :: xml_decoder_price(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> price;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}
bool
SQL_TABLE_book :: xml_decoder_quantity(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> quantity;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}


bool
SQL_TABLE_book :: copy_from_xml(const tinyxml2::XMLElement *el)
{
    init();
    if (xml_decoders_initialized == false)
    {
        xml_decoders["bookid"] =
            &SQL_TABLE_book::xml_decoder_bookid;
        xml_decoders["title"] =
            &SQL_TABLE_book::xml_decoder_title;
        xml_decoders["isbn"] =
            &SQL_TABLE_book::xml_decoder_isbn;
        xml_decoders["price"] =
            &SQL_TABLE_book::xml_decoder_price;
        xml_decoders["quantity"] =
            &SQL_TABLE_book::xml_decoder_quantity;

        xml_decoders_initialized = true;
    }
    if (strcmp(el->Value(), "book") != 0)
    {
        if (err_log_func)
        {
            std::ostringstream err;
            err << "SQL_TABLE_book :: "
                << "copy_from_xml : node name is " << el->Value()
                << " not 'book'!\n";
            err_log_func(log_arg, err.str().c_str());
        }
        return false;
    }
    const tinyxml2::XMLElement * child = el->FirstChildElement();
    while (child)
    {
        const char * v = child->Value();
        if (v && v[0] != 0)
        {
            xml_decoder_map_t::iterator it = xml_decoders.find(v);
            if (it != xml_decoders.end())
            {
                xml_decoder_func_t f = it->second;
                if ((this->*f)(child) == false)
                    return false;
            }
        }
        child = child->NextSiblingElement();
    }
    return true;
}

#endif

//static
bool SQL_TABLE_book :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"book\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("select from tables: %d (%s)", r, msg);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"book\",1)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "book", v, 1);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (1) "
            "WHERE name = \"book\"",
            NULL, NULL, NULL);
    }
    else
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("select from tables / step r = %d (%s)", r, msg);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_book :: table_create(sqlite3 *pdb)
{
    std::ostringstream  e;
    char * errmsg = NULL;
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    errmsg = NULL;
    r = sqlite3_exec(pdb, "CREATE TABLE book "
        "(bookid integer PRIMARY KEY AUTOINCREMENT, title text, isbn text, price double, quantity integer)",
        NULL, NULL, &errmsg);

    printf("CREATE TABLE: CREATE TABLE book "
           "(bookid integer PRIMARY KEY AUTOINCREMENT, title text, isbn text, price double, quantity integer)\n");

    if (r != SQLITE_OK)
    {
        e << "CREATE TABLE returned r = " << r
          << " error '" << errmsg << "'\n";
        printf("SQL ERROR: %s\n", e.str().c_str());
    	if (errmsg != NULL)
            sqlite3_free(errmsg);
        if (err_log_func)
            err_log_func(log_arg, e.str());
        return false;
    }

    errmsg = NULL;
    r = sqlite3_exec(pdb,"CREATE INDEX book_bookid "
                 "ON book (bookid)",
        NULL, NULL, &errmsg);
    printf("CREATE INDEX: CREATE INDEX book_bookid "
           "ON book (bookid)\n");
    if (r != SQLITE_OK)
    {
        e << "CREATE INDEX returned r = " << r
          << " error '" << errmsg << "'\n";
        printf("SQL ERROR: %s\n", e.str().c_str());
        if (errmsg != NULL)
            sqlite3_free(errmsg);
        if (err_log_func)
            err_log_func(log_arg, e.str());
        return false;
    }
    errmsg = NULL;
    r = sqlite3_exec(pdb,"CREATE INDEX book_isbn "
                 "ON book (isbn)",
        NULL, NULL, &errmsg);
    printf("CREATE INDEX: CREATE INDEX book_isbn "
           "ON book (isbn)\n");
    if (r != SQLITE_OK)
    {
        e << "CREATE INDEX returned r = " << r
          << " error '" << errmsg << "'\n";
        printf("SQL ERROR: %s\n", e.str().c_str());
        if (errmsg != NULL)
            sqlite3_free(errmsg);
        if (err_log_func)
            err_log_func(log_arg, e.str());
        return false;
    }


    return true;
}

//static
void SQL_TABLE_book :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE book",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE book\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}

#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
//static
void SQL_TABLE_book :: export_xml(sqlite3 *pdb,
                                           tinyxml2::XMLElement *el)
{
    SQL_TABLE_book row(pdb);

    bool ok = row.get_all();
    while (ok)
    {
        row.get_subtables();
        tinyxml2::XMLElement * row_el =
            el->GetDocument()->NewElement("book");
        row.copy_to_xml(row_el);
        el->InsertEndChild(row_el);
        ok = row.get_next();
    }
}

//static
bool SQL_TABLE_book :: import_xml(sqlite3 *pdb,
                                           tinyxml2::XMLElement *el)
{
    tinyxml2::XMLElement * row_el;
    SQL_TABLE_book  row(pdb);

    for (row_el = el->FirstChildElement(); row_el;
         row_el = row_el->NextSiblingElement())
    {
        row.copy_from_xml(row_el);
        // use insert_force because the xml may include AUTOINCR
        // values which must be set the hard way.
        row.insert_force();
        row.insert_subtables_force();
    }

    return true;
}
#endif

SQL_TABLE_checkouts :: SQL_TABLE_checkouts(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
    xml_decoders_initialized = false;
#endif
}

// copy constructor, duplicates all the data fields (including rowid)
// but does not duplicate the statement pointers, because then they'd
// get double-freed.
SQL_TABLE_checkouts :: SQL_TABLE_checkouts(
    const SQL_TABLE_checkouts &other)
{
    init_statements();
    operator=(other);
}

void
SQL_TABLE_checkouts :: operator=(const SQL_TABLE_checkouts &other)
{
    pdb = other.pdb;
    rowid = other.rowid;
    bookid2 = other.bookid2;
    userid2 = other.userid2;
    duedate = other.duedate;

}

void
SQL_TABLE_checkouts :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_insert_force = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

    pStmt_by_bookid2 = NULL;
    pStmt_by_userid2 = NULL;


    pStmt_get_due_now = NULL;




    previous_get = NULL;
    init();
}

SQL_TABLE_checkouts :: ~SQL_TABLE_checkouts(void)
{
    finalize();
}

void
SQL_TABLE_checkouts :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_insert_force)
        sqlite3_finalize(pStmt_insert_force);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

    if (pStmt_by_bookid2)
        sqlite3_finalize(pStmt_by_bookid2);
    if (pStmt_by_userid2)
        sqlite3_finalize(pStmt_by_userid2);


    if (pStmt_get_due_now)
        sqlite3_finalize(pStmt_get_due_now);




    init_statements();
}

void SQL_TABLE_checkouts :: init(void)
{
    rowid = -1;
    bookid2 = 0;
    userid2 = 0;
    duedate = 0;

    previous_get = NULL;
}

//static
void SQL_TABLE_checkouts :: get_column_descriptors(
    std::vector<SQL_Column_Descriptor> &columns)
{
    SQL_Column_Descriptor desc;
    columns.clear();

    desc.tablename = "checkouts";
    desc.fieldname = "bookid2";
    desc.ctype = "int32_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT;
    columns.push_back(desc);

    desc.tablename = "checkouts";
    desc.fieldname = "userid2";
    desc.ctype = "int32_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT;
    columns.push_back(desc);

    desc.tablename = "checkouts";
    desc.fieldname = "duedate";
    desc.ctype = "int64_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT64;
    columns.push_back(desc);

}

std::string SQL_TABLE_checkouts :: rowid_toString(void)
{
    std::ostringstream out;
    out << rowid;
    return out.str();
}

std::string
SQL_TABLE_checkouts :: bookid2_toString(void)
{
    std::ostringstream out;
    out << bookid2;
    return out.str();
}
std::string
SQL_TABLE_checkouts :: userid2_toString(void)
{
    std::ostringstream out;
    out << userid2;
    return out.str();
}
std::string
SQL_TABLE_checkouts :: duedate_toString(void)
{
    std::ostringstream out;
    out << duedate;
    return out.str();
}


std::string SQL_TABLE_checkouts :: toString(void)
{
    std::ostringstream out;
    out << "rowid:" << rowid_toString() << ";";
    out << "bookid2: " << bookid2_toString() << "; ";
    out << "userid2: " << userid2_toString() << "; ";
    out << "duedate: " << duedate_toString() << "; ";

    return out.str();
}

void SQL_TABLE_checkouts :: set_db(sqlite3 *_pdb)
{
    finalize();
    pdb = _pdb;

}

bool SQL_TABLE_checkouts :: get_columns(sqlite3_stmt * pStmt)
{
    int got;
    if (log_row_func)
        log_row_msg.str("checkouts: ");

    rowid = sqlite3_column_int64(pStmt, 0);
    if (log_row_func)
        log_row_msg << "rowid:" << rowid << "; ";

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (bookid2) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    bookid2 = sqlite3_column_int(pStmt, 1);
    if (log_row_func)
        log_row_msg << "bookid2:" << bookid2 << "; ";
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (userid2) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    userid2 = sqlite3_column_int(pStmt, 2);
    if (log_row_func)
        log_row_msg << "userid2:" << userid2 << "; ";
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (duedate) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    duedate = sqlite3_column_int64(pStmt, 3);
    if (log_row_func)
        log_row_msg << "duedate:" << duedate << "; ";


    if (log_row_func)
    {
        log_row_func(log_arg, log_row_msg.str());
        log_row_msg.str("");
    }

    return true;
}

bool SQL_TABLE_checkouts :: get_by_bookid2(int32_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_bookid2 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts WHERE bookid2 = ?",
            -1, &pStmt_by_bookid2, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_bookid2);

    r = sqlite3_bind_int(pStmt_by_bookid2, 1, v);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_bookid2);

    r = sqlite3_step(pStmt_by_bookid2);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_bookid2);
        previous_get = pStmt_by_bookid2;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_checkouts :: get_by_userid2(int32_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_userid2 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts WHERE userid2 = ?",
            -1, &pStmt_by_userid2, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_userid2);

    r = sqlite3_bind_int(pStmt_by_userid2, 1, v);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_userid2);

    r = sqlite3_step(pStmt_by_userid2);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_userid2);
        previous_get = pStmt_by_userid2;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}



bool SQL_TABLE_checkouts :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_checkouts :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO checkouts "
            "(bookid2, userid2, duedate) "
            "values (?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
	    const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing INSERT", r, msg);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int(pStmt_insert, 1,
                             bookid2);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind bookid2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 2,
                             userid2);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind userid2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_insert, 3,
                             duedate);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: bind duedate: r = %d (%s)", r, msg);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert: r = %d (%s)", r, msg);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);
    
    return true;
}

bool SQL_TABLE_checkouts :: insert_force(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT (force) before set_db");
        return false;
    }

    if (pStmt_insert_force == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT OR REPLACE INTO checkouts "
            "(bookid2, userid2, duedate) "
            "values (?,?,?)",
            -1, &pStmt_insert_force, NULL);
        if (r != SQLITE_OK)
        {
	    const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing INSERT (force)", r, msg);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert_force);

    r = sqlite3_bind_int(pStmt_insert_force, 1,
                             bookid2);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind bookid2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert_force, 2,
                             userid2);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind userid2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_insert_force, 3,
                             duedate);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: bind duedate: r = %d (%s)", r, msg);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert_force);

    r = sqlite3_step(pStmt_insert_force);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("insert_force: r = %d (%s)", r, msg);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_checkouts :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE checkouts SET "
            "(bookid2, userid2, duedate) "
            "= (?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing UPDATE", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int(pStmt_update, 1,
                             bookid2);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind bookid2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 2,
                             userid2);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind userid2: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_update, 3,
                             duedate);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: bind duedate: r = %d (%s)", r, msg);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update,
                           4, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("update: r = %d (%s)", r, msg);
        return false;
    }

    return true;
}

bool SQL_TABLE_checkouts :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM checkouts WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing DELETE", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("delete: r = %d (%s)", r, msg);
        return false;
    }

    return true;
}

bool SQL_TABLE_checkouts :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for get_by_rowid",
                      r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_checkouts :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for get_all", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}



void SQL_TABLE_checkouts :: get_subtables(void)
{

}

void SQL_TABLE_checkouts :: insert_subtables(void)
{

}

void SQL_TABLE_checkouts :: insert_subtables_force(void)
{

}

bool SQL_TABLE_checkouts :: get_due_now(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_due_now == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid2, userid2, duedate FROM checkouts "
            "WHERE duedate < ?",
            -1, &pStmt_get_due_now, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT for "
                   "CUSTOM-GET due_now", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_due_now);

    r = sqlite3_bind_int64(pStmt_get_due_now,
                             1, v1);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_due_now);

    r = sqlite3_step(pStmt_get_due_now);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_due_now);
        previous_get = pStmt_get_due_now;
        ret = true;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}



#ifdef INCLUDE_SQLITE3GEN_PROTOBUF_SUPPORT
void
SQL_TABLE_checkouts :: copy_to_proto(
              library::TABLE_checkouts_m &msg)
{
    msg.set_schema_version(TABLE_VERSION);
    msg.set_bookid2(bookid2);
    msg.set_userid2(userid2);
    msg.set_duedate(duedate);

}

void
SQL_TABLE_checkouts :: copy_from_proto(
              const library::TABLE_checkouts_m &msg)
{
    if (msg.has_schema_version() && msg.schema_version() != TABLE_VERSION)
    {
        // NOTE : if this becomes a problem in the future, we could
        //        enhance sql3gen to allow the user to register a
        //        callback function which can convert a message from
        //        one schema version to another.
        std::ostringstream err;
        err << "SQL_TABLE_checkouts :: "
            << "copy_from_proto : recvd protobuf message with "
            << "schema version " << msg.schema_version()
            << " (supported is " << TABLE_VERSION
            << ")\n";
        if (err_log_func)
            err_log_func(log_arg, err.str());
        else
            std::cerr << err.str();
    }
    if (msg.has_bookid2())
        bookid2 = msg.bookid2();
    else
        bookid2 = 0;

    if (msg.has_userid2())
        userid2 = msg.userid2();
    else
        userid2 = 0;

    if (msg.has_duedate())
        duedate = msg.duedate();
    else
        duedate = 0;


}

#endif
#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
void
SQL_TABLE_checkouts :: copy_to_xml(tinyxml2::XMLElement *el)
{
    el->SetValue("checkouts");
    el->SetAttribute("type", "row");
    el->SetAttribute("rowid", (int64_t) rowid);

    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("bookid2");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << bookid2;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("userid2");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << userid2;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }
    {
        tinyxml2::XMLElement * child =
            el->GetDocument()->NewElement("duedate");
        child->SetAttribute("type", "pod");
        el->InsertEndChild(child);
        std::ostringstream s;
        s << duedate;
        tinyxml2::XMLText * v = el->GetDocument()->NewText(s.str().c_str());
        child->InsertEndChild(v);
    }

}

bool
SQL_TABLE_checkouts :: xml_decoder_bookid2(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> bookid2;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}
bool
SQL_TABLE_checkouts :: xml_decoder_userid2(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> userid2;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}
bool
SQL_TABLE_checkouts :: xml_decoder_duedate(const tinyxml2::XMLElement *el)
{
    const tinyxml2::XMLNode * n = el->FirstChild();
    if (n)
    {
        const char * v = n->Value();
        if (v && v[0] != 0)
        {
            std::istringstream s(v);
            s >> duedate;
            if (s.fail())
                return false;
            return true;
        }
    }
    return false;
}


bool
SQL_TABLE_checkouts :: copy_from_xml(const tinyxml2::XMLElement *el)
{
    init();
    if (xml_decoders_initialized == false)
    {
        xml_decoders["bookid2"] =
            &SQL_TABLE_checkouts::xml_decoder_bookid2;
        xml_decoders["userid2"] =
            &SQL_TABLE_checkouts::xml_decoder_userid2;
        xml_decoders["duedate"] =
            &SQL_TABLE_checkouts::xml_decoder_duedate;

        xml_decoders_initialized = true;
    }
    if (strcmp(el->Value(), "checkouts") != 0)
    {
        if (err_log_func)
        {
            std::ostringstream err;
            err << "SQL_TABLE_checkouts :: "
                << "copy_from_xml : node name is " << el->Value()
                << " not 'checkouts'!\n";
            err_log_func(log_arg, err.str().c_str());
        }
        return false;
    }
    const tinyxml2::XMLElement * child = el->FirstChildElement();
    while (child)
    {
        const char * v = child->Value();
        if (v && v[0] != 0)
        {
            xml_decoder_map_t::iterator it = xml_decoders.find(v);
            if (it != xml_decoders.end())
            {
                xml_decoder_func_t f = it->second;
                if ((this->*f)(child) == false)
                    return false;
            }
        }
        child = child->NextSiblingElement();
    }
    return true;
}

#endif

//static
bool SQL_TABLE_checkouts :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"checkouts\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("select from tables: %d (%s)", r, msg);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"checkouts\",1)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "checkouts", v, 1);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (1) "
            "WHERE name = \"checkouts\"",
            NULL, NULL, NULL);
    }
    else
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("select from tables / step r = %d (%s)", r, msg);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_checkouts :: table_create(sqlite3 *pdb)
{
    std::ostringstream  e;
    char * errmsg = NULL;
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    errmsg = NULL;
    r = sqlite3_exec(pdb, "CREATE TABLE checkouts "
        "(bookid2 integer, userid2 integer, duedate int64, FOREIGN KEY(bookid2) REFERENCES book(bookid), FOREIGN KEY(userid2) REFERENCES user(userid))",
        NULL, NULL, &errmsg);

    printf("CREATE TABLE: CREATE TABLE checkouts "
           "(bookid2 integer, userid2 integer, duedate int64, FOREIGN KEY(bookid2) REFERENCES book(bookid), FOREIGN KEY(userid2) REFERENCES user(userid))\n");

    if (r != SQLITE_OK)
    {
        e << "CREATE TABLE returned r = " << r
          << " error '" << errmsg << "'\n";
        printf("SQL ERROR: %s\n", e.str().c_str());
    	if (errmsg != NULL)
            sqlite3_free(errmsg);
        if (err_log_func)
            err_log_func(log_arg, e.str());
        return false;
    }

    errmsg = NULL;
    r = sqlite3_exec(pdb,"CREATE INDEX checkouts_bookid2 "
                 "ON checkouts (bookid2)",
        NULL, NULL, &errmsg);
    printf("CREATE INDEX: CREATE INDEX checkouts_bookid2 "
           "ON checkouts (bookid2)\n");
    if (r != SQLITE_OK)
    {
        e << "CREATE INDEX returned r = " << r
          << " error '" << errmsg << "'\n";
        printf("SQL ERROR: %s\n", e.str().c_str());
        if (errmsg != NULL)
            sqlite3_free(errmsg);
        if (err_log_func)
            err_log_func(log_arg, e.str());
        return false;
    }
    errmsg = NULL;
    r = sqlite3_exec(pdb,"CREATE INDEX checkouts_userid2 "
                 "ON checkouts (userid2)",
        NULL, NULL, &errmsg);
    printf("CREATE INDEX: CREATE INDEX checkouts_userid2 "
           "ON checkouts (userid2)\n");
    if (r != SQLITE_OK)
    {
        e << "CREATE INDEX returned r = " << r
          << " error '" << errmsg << "'\n";
        printf("SQL ERROR: %s\n", e.str().c_str());
        if (errmsg != NULL)
            sqlite3_free(errmsg);
        if (err_log_func)
            err_log_func(log_arg, e.str());
        return false;
    }


    return true;
}

//static
void SQL_TABLE_checkouts :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE checkouts",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE checkouts\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}

#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
//static
void SQL_TABLE_checkouts :: export_xml(sqlite3 *pdb,
                                           tinyxml2::XMLElement *el)
{
    SQL_TABLE_checkouts row(pdb);

    bool ok = row.get_all();
    while (ok)
    {
        row.get_subtables();
        tinyxml2::XMLElement * row_el =
            el->GetDocument()->NewElement("checkouts");
        row.copy_to_xml(row_el);
        el->InsertEndChild(row_el);
        ok = row.get_next();
    }
}

//static
bool SQL_TABLE_checkouts :: import_xml(sqlite3 *pdb,
                                           tinyxml2::XMLElement *el)
{
    tinyxml2::XMLElement * row_el;
    SQL_TABLE_checkouts  row(pdb);

    for (row_el = el->FirstChildElement(); row_el;
         row_el = row_el->NextSiblingElement())
    {
        row.copy_from_xml(row_el);
        // use insert_force because the xml may include AUTOINCR
        // values which must be set the hard way.
        row.insert_force();
        row.insert_subtables_force();
    }

    return true;
}
#endif

SQL_SELECT_due_books :: SQL_SELECT_due_books(sqlite3 *_pdb /*= NULL*/)
{
    pStmt_get_query = NULL;
    pdb = _pdb;
}

SQL_SELECT_due_books :: ~SQL_SELECT_due_books(void)
{
    if (pStmt_get_query != NULL)
        sqlite3_finalize(pStmt_get_query);
}

//static
void SQL_SELECT_due_books :: get_column_descriptors(
    std::vector<SQL_Column_Descriptor> &columns)
{
    SQL_Column_Descriptor desc;
    columns.clear();

    desc.tablename = "user";
    desc.fieldname = "rowid";
    desc.ctype = "sqlite3_int64";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT64;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "firstname";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "lastname";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "test2";
    desc.ctype = "bool";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_BOOL;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "test3";
    desc.ctype = "sample::library2::EnumField_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_ENUM;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "proto";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_BLOB;
    desc.sqlite3gen_type = TYPE_BLOB;
    columns.push_back(desc);

    desc.tablename = "book";
    desc.fieldname = "rowid";
    desc.ctype = "sqlite3_int64";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT64;
    columns.push_back(desc);

    desc.tablename = "book";
    desc.fieldname = "title";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "checkouts";
    desc.fieldname = "rowid";
    desc.ctype = "sqlite3_int64";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT64;
    columns.push_back(desc);

    desc.tablename = "checkouts";
    desc.fieldname = "duedate";
    desc.ctype = "int64_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT64;
    columns.push_back(desc);

}

void
SQL_SELECT_due_books :: set_db(sqlite3 *_pdb)
{
    if (pStmt_get_query != NULL)
        sqlite3_finalize(pStmt_get_query);
    pStmt_get_query = NULL;
    pdb = _pdb;
}

bool
SQL_SELECT_due_books :: get_columns(void)
{
    int got;
    sqlite3_stmt * pStmt = pStmt_get_query;
    if (log_row_func)
        log_row_msg.str("due_books: ");

    got = sqlite3_column_type(pStmt, 0);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (user_rowid) : "
                "column 0 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    user_rowid = sqlite3_column_int64(pStmt, 0);
    if (log_row_func)
        log_row_msg << "user_rowid:" << user_rowid << "; ";
    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (user_firstname) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 1);
        int len = sqlite3_column_bytes(pStmt, 1);
        user_firstname.clear();
        user_firstname.resize(len);
        memcpy((void*)user_firstname.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "user_firstname:\"" << user_firstname << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "user_firstname:(" << user_firstname.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (user_lastname) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        user_lastname.clear();
        user_lastname.resize(len);
        memcpy((void*)user_lastname.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "user_lastname:\"" << user_lastname << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "user_lastname:(" << user_lastname.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (user_test2) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sqlite3_column_int(pStmt, 3))
        user_test2 = true;
    else
        user_test2 = false;
    if (log_row_func)
        log_row_msg << "user_test2:"
                    << (user_test2 ? "true" : "false") << "; ";
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (user_test3) : "
                "column 4 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sample::library2::EnumField_t_IsValid(user_test3))
        user_test3 = (sample::library2::EnumField_t) sqlite3_column_int(
            pStmt, 4);
    else
        user_test3 = sample::library2::ENUM_TWO;

    if (log_row_func)
        log_row_msg << "user_test3:"
                    << sample::library2::EnumField_t_Name(user_test3) << "; ";
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_BLOB)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (user_proto) : "
                "column 5 wrong type (%d %d)",
                got, SQLITE_BLOB);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_blob(
            pStmt, 5);
        int len = sqlite3_column_bytes(pStmt, 5);
        user_proto.clear();
        user_proto.resize(len);
        memcpy((void*)user_proto.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "user_proto:\"" << user_proto << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "user_proto:(" << user_proto.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 6);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (book_rowid) : "
                "column 6 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    book_rowid = sqlite3_column_int64(pStmt, 6);
    if (log_row_func)
        log_row_msg << "book_rowid:" << book_rowid << "; ";
    got = sqlite3_column_type(pStmt, 7);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (book_title) : "
                "column 7 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 7);
        int len = sqlite3_column_bytes(pStmt, 7);
        book_title.clear();
        book_title.resize(len);
        memcpy((void*)book_title.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "book_title:\"" << book_title << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "book_title:(" << book_title.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 8);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (checkouts_rowid) : "
                "column 8 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    checkouts_rowid = sqlite3_column_int64(pStmt, 8);
    if (log_row_func)
        log_row_msg << "checkouts_rowid:" << checkouts_rowid << "; ";
    got = sqlite3_column_type(pStmt, 9);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (checkouts_duedate) : "
                "column 9 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    checkouts_duedate = sqlite3_column_int64(pStmt, 9);
    if (log_row_func)
        log_row_msg << "checkouts_duedate:" << checkouts_duedate << "; ";


    if (log_row_func)
    {
        log_row_func(log_arg, log_row_msg.str());
        log_row_msg.str("");
    }

    return true;
}

std::string
SQL_SELECT_due_books :: user_rowid_toString(void)
{
    std::ostringstream out;
    out << user_rowid;
    return out.str();
}
std::string
SQL_SELECT_due_books :: user_firstname_toString(void)
{
    std::ostringstream out;
    out << "\"" << user_firstname << "\"";
    return out.str();
}
std::string
SQL_SELECT_due_books :: user_lastname_toString(void)
{
    std::ostringstream out;
    out << "\"" << user_lastname << "\"";
    return out.str();
}
std::string
SQL_SELECT_due_books :: user_test2_toString(void)
{
    return user_test2 ? "true" : "false";
}
std::string
SQL_SELECT_due_books :: user_test3_toString(void)
{
    return sample::library2::EnumField_t_Name(user_test3);
}
std::string
SQL_SELECT_due_books :: user_proto_toString(void)
{
    std::ostringstream out;
    out << "BLOB:";
    for (size_t ind = 0; ind < user_proto.size(); ind++)
    {
        uint8_t b = (uint8_t) user_proto[ind];
        out << std::hex << std::setw(2) << (int) b;
    }
    return out.str();
}
std::string
SQL_SELECT_due_books :: book_rowid_toString(void)
{
    std::ostringstream out;
    out << book_rowid;
    return out.str();
}
std::string
SQL_SELECT_due_books :: book_title_toString(void)
{
    std::ostringstream out;
    out << "\"" << book_title << "\"";
    return out.str();
}
std::string
SQL_SELECT_due_books :: checkouts_rowid_toString(void)
{
    std::ostringstream out;
    out << checkouts_rowid;
    return out.str();
}
std::string
SQL_SELECT_due_books :: checkouts_duedate_toString(void)
{
    std::ostringstream out;
    out << checkouts_duedate;
    return out.str();
}


std::string
SQL_SELECT_due_books :: toString(void)
{
    std::ostringstream out;
    out << "user_rowid: "
        << user_rowid_toString() << "; ";
    out << "user_firstname: "
        << user_firstname_toString() << "; ";
    out << "user_lastname: "
        << user_lastname_toString() << "; ";
    out << "user_test2: "
        << user_test2_toString() << "; ";
    out << "user_test3: "
        << user_test3_toString() << "; ";
    out << "user_proto: "
        << user_proto_toString() << "; ";
    out << "book_rowid: "
        << book_rowid_toString() << "; ";
    out << "book_title: "
        << book_title_toString() << "; ";
    out << "checkouts_rowid: "
        << checkouts_rowid_toString() << "; ";
    out << "checkouts_duedate: "
        << checkouts_duedate_toString() << "; ";

    return out.str();
}

bool
SQL_SELECT_due_books :: get(int32_t v1, int32_t v2)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
        return false;

    if (pStmt_get_query == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT user.rowid, user.firstname, user.lastname, user.test2, user.test3, user.proto, book.rowid, book.title, checkouts.rowid, checkouts.duedate "
            "FROM user, checkouts, book WHERE checkouts.bookid2 = book.bookid AND checkouts.userid2 = user.userid AND book.bookid > ? AND book.bookid < ? ORDER BY duedate ASC",
            -1, &pStmt_get_query, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_query);

    r = sqlite3_bind_int(pStmt_get_query,
                             1, v1);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_get_query,
                             2, v2);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_query);

    r = sqlite3_step(pStmt_get_query);
    if (r == SQLITE_ROW)
        ret = get_columns();

    return ret;
}

bool
SQL_SELECT_due_books :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || pStmt_get_query == NULL)
        return false;

    r = sqlite3_step(pStmt_get_query);
    if (r == SQLITE_ROW)
        ret = get_columns();

    return ret;
}

SQL_SELECT_due_books2 :: SQL_SELECT_due_books2(sqlite3 *_pdb /*= NULL*/)
{
    pStmt_get_query = NULL;
    pdb = _pdb;
}

SQL_SELECT_due_books2 :: ~SQL_SELECT_due_books2(void)
{
    if (pStmt_get_query != NULL)
        sqlite3_finalize(pStmt_get_query);
}

//static
void SQL_SELECT_due_books2 :: get_column_descriptors(
    std::vector<SQL_Column_Descriptor> &columns)
{
    SQL_Column_Descriptor desc;
    columns.clear();

    desc.tablename = "user";
    desc.fieldname = "rowid";
    desc.ctype = "sqlite3_int64";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT64;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "firstname";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "lastname";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "test2";
    desc.ctype = "bool";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_BOOL;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "test3";
    desc.ctype = "sample::library2::EnumField_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_ENUM;
    columns.push_back(desc);

    desc.tablename = "user";
    desc.fieldname = "proto";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_BLOB;
    desc.sqlite3gen_type = TYPE_BLOB;
    columns.push_back(desc);

    desc.tablename = "book";
    desc.fieldname = "rowid";
    desc.ctype = "sqlite3_int64";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT64;
    columns.push_back(desc);

    desc.tablename = "book";
    desc.fieldname = "title";
    desc.ctype = "std::string";
    desc.sqlite_type = SQLITE_TEXT;
    desc.sqlite3gen_type = TYPE_TEXT;
    columns.push_back(desc);

    desc.tablename = "checkouts";
    desc.fieldname = "rowid";
    desc.ctype = "sqlite3_int64";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT64;
    columns.push_back(desc);

    desc.tablename = "checkouts";
    desc.fieldname = "duedate";
    desc.ctype = "int64_t";
    desc.sqlite_type = SQLITE_INTEGER;
    desc.sqlite3gen_type = TYPE_INT64;
    columns.push_back(desc);

}

void
SQL_SELECT_due_books2 :: set_db(sqlite3 *_pdb)
{
    if (pStmt_get_query != NULL)
        sqlite3_finalize(pStmt_get_query);
    pStmt_get_query = NULL;
    pdb = _pdb;
}

bool
SQL_SELECT_due_books2 :: get_columns(void)
{
    int got;
    sqlite3_stmt * pStmt = pStmt_get_query;
    if (log_row_func)
        log_row_msg.str("due_books2: ");

    got = sqlite3_column_type(pStmt, 0);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (user_rowid) : "
                "column 0 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    user_rowid = sqlite3_column_int64(pStmt, 0);
    if (log_row_func)
        log_row_msg << "user_rowid:" << user_rowid << "; ";
    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (user_firstname) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 1);
        int len = sqlite3_column_bytes(pStmt, 1);
        user_firstname.clear();
        user_firstname.resize(len);
        memcpy((void*)user_firstname.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "user_firstname:\"" << user_firstname << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "user_firstname:(" << user_firstname.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (user_lastname) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        user_lastname.clear();
        user_lastname.resize(len);
        memcpy((void*)user_lastname.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "user_lastname:\"" << user_lastname << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "user_lastname:(" << user_lastname.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (user_test2) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sqlite3_column_int(pStmt, 3))
        user_test2 = true;
    else
        user_test2 = false;
    if (log_row_func)
        log_row_msg << "user_test2:"
                    << (user_test2 ? "true" : "false") << "; ";
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (user_test3) : "
                "column 4 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sample::library2::EnumField_t_IsValid(user_test3))
        user_test3 = (sample::library2::EnumField_t) sqlite3_column_int(
            pStmt, 4);
    else
        user_test3 = sample::library2::ENUM_TWO;

    if (log_row_func)
        log_row_msg << "user_test3:"
                    << sample::library2::EnumField_t_Name(user_test3) << "; ";
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_BLOB)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (user_proto) : "
                "column 5 wrong type (%d %d)",
                got, SQLITE_BLOB);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_blob(
            pStmt, 5);
        int len = sqlite3_column_bytes(pStmt, 5);
        user_proto.clear();
        user_proto.resize(len);
        memcpy((void*)user_proto.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "user_proto:\"" << user_proto << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "user_proto:(" << user_proto.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 6);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (book_rowid) : "
                "column 6 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    book_rowid = sqlite3_column_int64(pStmt, 6);
    if (log_row_func)
        log_row_msg << "book_rowid:" << book_rowid << "; ";
    got = sqlite3_column_type(pStmt, 7);
    if (got != SQLITE_TEXT)
    {
#if 0 // coerce everything to string.
        PRINT_ERR("get_columns (book_title) : "
                "column 7 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
#endif
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 7);
        int len = sqlite3_column_bytes(pStmt, 7);
        book_title.clear();
        book_title.resize(len);
        memcpy((void*)book_title.c_str(), ptr, len);
    }
    if (log_row_func)
    {
        if (got == SQLITE_TEXT)
            log_row_msg << "book_title:\"" << book_title << "\"; ";
        else // can't print a blob! just print length
            log_row_msg << "book_title:(" << book_title.size()
                        << " bytes); ";
    }
    got = sqlite3_column_type(pStmt, 8);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (checkouts_rowid) : "
                "column 8 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    checkouts_rowid = sqlite3_column_int64(pStmt, 8);
    if (log_row_func)
        log_row_msg << "checkouts_rowid:" << checkouts_rowid << "; ";
    got = sqlite3_column_type(pStmt, 9);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (checkouts_duedate) : "
                "column 9 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    checkouts_duedate = sqlite3_column_int64(pStmt, 9);
    if (log_row_func)
        log_row_msg << "checkouts_duedate:" << checkouts_duedate << "; ";


    if (log_row_func)
    {
        log_row_func(log_arg, log_row_msg.str());
        log_row_msg.str("");
    }

    return true;
}

std::string
SQL_SELECT_due_books2 :: user_rowid_toString(void)
{
    std::ostringstream out;
    out << user_rowid;
    return out.str();
}
std::string
SQL_SELECT_due_books2 :: user_firstname_toString(void)
{
    std::ostringstream out;
    out << "\"" << user_firstname << "\"";
    return out.str();
}
std::string
SQL_SELECT_due_books2 :: user_lastname_toString(void)
{
    std::ostringstream out;
    out << "\"" << user_lastname << "\"";
    return out.str();
}
std::string
SQL_SELECT_due_books2 :: user_test2_toString(void)
{
    return user_test2 ? "true" : "false";
}
std::string
SQL_SELECT_due_books2 :: user_test3_toString(void)
{
    return sample::library2::EnumField_t_Name(user_test3);
}
std::string
SQL_SELECT_due_books2 :: user_proto_toString(void)
{
    std::ostringstream out;
    out << "BLOB:";
    for (size_t ind = 0; ind < user_proto.size(); ind++)
    {
        uint8_t b = (uint8_t) user_proto[ind];
        out << std::hex << std::setw(2) << (int) b;
    }
    return out.str();
}
std::string
SQL_SELECT_due_books2 :: book_rowid_toString(void)
{
    std::ostringstream out;
    out << book_rowid;
    return out.str();
}
std::string
SQL_SELECT_due_books2 :: book_title_toString(void)
{
    std::ostringstream out;
    out << "\"" << book_title << "\"";
    return out.str();
}
std::string
SQL_SELECT_due_books2 :: checkouts_rowid_toString(void)
{
    std::ostringstream out;
    out << checkouts_rowid;
    return out.str();
}
std::string
SQL_SELECT_due_books2 :: checkouts_duedate_toString(void)
{
    std::ostringstream out;
    out << checkouts_duedate;
    return out.str();
}


std::string
SQL_SELECT_due_books2 :: toString(void)
{
    std::ostringstream out;
    out << "user_rowid: "
        << user_rowid_toString() << "; ";
    out << "user_firstname: "
        << user_firstname_toString() << "; ";
    out << "user_lastname: "
        << user_lastname_toString() << "; ";
    out << "user_test2: "
        << user_test2_toString() << "; ";
    out << "user_test3: "
        << user_test3_toString() << "; ";
    out << "user_proto: "
        << user_proto_toString() << "; ";
    out << "book_rowid: "
        << book_rowid_toString() << "; ";
    out << "book_title: "
        << book_title_toString() << "; ";
    out << "checkouts_rowid: "
        << checkouts_rowid_toString() << "; ";
    out << "checkouts_duedate: "
        << checkouts_duedate_toString() << "; ";

    return out.str();
}

bool
SQL_SELECT_due_books2 :: get(int32_t v1, int32_t v2)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
        return false;

    if (pStmt_get_query == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT user.rowid, user.firstname, user.lastname, user.test2, user.test3, user.proto, book.rowid, book.title, checkouts.rowid, checkouts.duedate "
            "FROM user JOIN checkouts, book ON checkouts.bookid2 = book.bookid                     AND checkouts.userid2 = user.userid WHERE book.bookid > ?   AND book.bookid < ? ORDER BY duedate ASC ",
            -1, &pStmt_get_query, NULL);
        if (r != SQLITE_OK)
        {
            const char *msg = sqlite3_errmsg(pdb);
            PRINT_ERR("ERROR %d (%s) preparing SELECT", r, msg);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_query);

    r = sqlite3_bind_int(pStmt_get_query,
                             1, v1);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }
    r = sqlite3_bind_int(pStmt_get_query,
                             2, v2);
    if (r != SQLITE_OK)
    {
        const char *msg = sqlite3_errmsg(pdb);
        PRINT_ERR("bind: r = %d (%s)", r, msg);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_query);

    r = sqlite3_step(pStmt_get_query);
    if (r == SQLITE_ROW)
        ret = get_columns();

    return ret;
}

bool
SQL_SELECT_due_books2 :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || pStmt_get_query == NULL)
        return false;

    r = sqlite3_step(pStmt_get_query);
    if (r == SQLITE_ROW)
        ret = get_columns();

    return ret;
}

bool SQL_TABLE_ALL_TABLES :: init_all(sqlite3 *pdb, table_version_callback cb)
{
    sqlite3_stmt * s;
    sqlite3_prepare_v2(pdb,
        "select * from sqlite_master "
        "where name = \"tables\" and type = \"table\"",
        -1, &s, NULL);
    sqlite3_reset(s);
    int r = sqlite3_step(s);
    if (r == SQLITE_DONE)
    {
        // the table does NOT exist, create it
        sqlite3_exec(pdb,
                     "CREATE TABLE tables (name text, version int)",
                     NULL, NULL, NULL);
    }
    sqlite3_finalize(s);

    if (!SQL_TABLE_user::init(pdb, cb))
        return false;
    if (!SQL_TABLE_book::init(pdb, cb))
        return false;
    if (!SQL_TABLE_checkouts::init(pdb, cb))
        return false;


    return true;
}

void SQL_TABLE_ALL_TABLES :: table_drop_all(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        fprintf(stderr, "attempted DROP (all) with null db\n");
        return;
    }

    SQL_TABLE_user::table_drop(pdb);
    SQL_TABLE_book::table_drop(pdb);
    SQL_TABLE_checkouts::table_drop(pdb);


    sqlite3_exec(pdb,
                 "DROP TABLE tables",
                 NULL, NULL, NULL);
}

sql_log_function_t SQL_TABLE_ALL_TABLES :: log_upd_func = &dflt_log_upd;
sql_log_function_t SQL_TABLE_ALL_TABLES :: log_get_func = &dflt_log_get;
sql_row_function_t SQL_TABLE_ALL_TABLES :: log_row_func = &dflt_log_row;
sql_err_function_t SQL_TABLE_ALL_TABLES :: err_log_func = &dflt_log_err;
void *             SQL_TABLE_ALL_TABLES :: log_arg      = NULL;

void SQL_TABLE_ALL_TABLES :: register_log_funcs(
    sql_log_function_t _upd_func,
    sql_log_function_t _get_func,
    sql_row_function_t _row_func,
    sql_err_function_t _err_func,
    void *_arg)
{
    log_upd_func = _upd_func;
    log_get_func = _get_func;
    log_row_func = _row_func;
    err_log_func = _err_func;
    log_arg = _arg;
}

//static
void
SQL_TABLE_ALL_TABLES :: print_err(const char *function, int lineno,
                                     const char *format, ...)
{
    if (err_log_func == NULL)
        // don't bother formatting the args.
        return;

    std::ostringstream msg_out;
    msg_out << function << ":" << lineno << ": ";
    std::string msg = msg_out.str();

    size_t offset = msg.size();
    msg.resize(offset + 250);

    va_list ap;
    va_start(ap, format);
    size_t l = vsnprintf((char*)msg.c_str() + offset,
                         250, format, ap);
    va_end(ap);
    // note that *snprintf returns what it WOULD have written
    // if there was space! so l > msg.size means it truncated.
    if (l < 250)
        msg.resize(l + offset);
    err_log_func(log_arg, msg);
}

#ifdef INCLUDE_SQLITE3GEN_TINYXML2_SUPPORT
//static
void SQL_TABLE_ALL_TABLES :: export_xml_all(sqlite3 *pdb,
                                            tinyxml2::XMLDocument &doc)
{
    doc.InsertEndChild(doc.NewDeclaration());
    tinyxml2::XMLElement * root = doc.NewElement("library");
    tinyxml2::XMLElement * tab = NULL;
    doc.InsertEndChild(root);
    struct tm export_time;
    time_t now = time(NULL);
    localtime_r(&now, &export_time);
    char export_time_str[100];
    strftime(export_time_str, 100, "%Y-%m%d-%H%M%S", &export_time);
    root->SetAttribute("export_time", export_time_str);
    if (/*is_subtable*/ false)
    {
        tinyxml2::XMLComment * c = doc.NewComment(
            "table user is a subtable of another table");
        root->InsertEndChild(c);
    }
    else
    {
        tab = doc.NewElement("user");
        tab->SetAttribute("type", "table");
        tab->SetAttribute("version", 19);
        SQL_TABLE_user :: export_xml(pdb, tab);
        root->InsertEndChild(tab);
    }
    if (/*is_subtable*/ false)
    {
        tinyxml2::XMLComment * c = doc.NewComment(
            "table book is a subtable of another table");
        root->InsertEndChild(c);
    }
    else
    {
        tab = doc.NewElement("book");
        tab->SetAttribute("type", "table");
        tab->SetAttribute("version", 1);
        SQL_TABLE_book :: export_xml(pdb, tab);
        root->InsertEndChild(tab);
    }
    if (/*is_subtable*/ true)
    {
        tinyxml2::XMLComment * c = doc.NewComment(
            "table checkouts is a subtable of another table");
        root->InsertEndChild(c);
    }
    else
    {
        tab = doc.NewElement("checkouts");
        tab->SetAttribute("type", "table");
        tab->SetAttribute("version", 1);
        SQL_TABLE_checkouts :: export_xml(pdb, tab);
        root->InsertEndChild(tab);
    }

}

//static
bool SQL_TABLE_ALL_TABLES :: import_xml_all(sqlite3 *pdb,
                                            tinyxml2::XMLDocument &doc)
{
    tinyxml2::XMLElement * root = doc.RootElement();
    if (strcmp(root->Value(), "library") != 0)
    {
        fprintf(stderr, "ERROR: SQL_TABLE_ALL_TABLES :: import_xml_all : "
                "root element '%s' does not match package '%s'\n",
                root->Value(), "library");
        return false;
    }
    tinyxml2::XMLElement * table;
    for (table = root->FirstChildElement(); table;
         table = table->NextSiblingElement())
    {
        const char * table_name = table->Value();
    if (strcmp(table_name, "user") == 0)
    {
        if (SQL_TABLE_user::import_xml(pdb,table) == false)
            return false;
    }
    if (strcmp(table_name, "book") == 0)
    {
        if (SQL_TABLE_book::import_xml(pdb,table) == false)
            return false;
    }

    }
    return true;
}
#endif

SQL_TRANSACTION :: SQL_TRANSACTION(sqlite3 *_pdb /*= NULL*/,
                                   bool _commit_on_delete /*= false*/)
    : pdb(_pdb), commit_on_delete(_commit_on_delete), started(false)
{
}

SQL_TRANSACTION :: ~SQL_TRANSACTION(void)
{
    finish(commit_on_delete);
}

void
SQL_TRANSACTION :: set_db(sqlite3 *_pdb)
{
    finish(commit_on_delete);
    pdb = _pdb;
}

bool
SQL_TRANSACTION :: begin(void)
{
    if (pdb == NULL)
        return false;

    bool ret = false;
    char *msg = NULL;
    int r = sqlite3_exec(pdb, "BEGIN TRANSACTION", NULL, NULL, &msg);

    if (r != SQLITE_OK)
        PRINT_ERR("ERROR SQL_TRANSACTION BEGIN: %d (%s)\n",
                  r, msg);
    else
    {
        if (log_upd_func)
        {
            sqlite3_stmt * pStmt;
            sqlite3_prepare_v2(pdb, "BEGIN TRANSACTION",  -1, &pStmt, NULL);
            log_upd_func(log_arg, pStmt);
            sqlite3_finalize(pStmt);
        }
        ret = started = true;
    }

    if (msg)
        sqlite3_free(msg);

    return ret;
}

bool
SQL_TRANSACTION :: finish(bool commit)
{
    bool ret = false;
    if (pdb == NULL)
        return ret;
    char *msg = NULL;
    int r = 0;
    if (started)
    {
        if (commit)
        {
            r = sqlite3_exec(pdb, "COMMIT TRANSACTION", NULL, NULL, &msg);
            if (r != SQLITE_OK)
                PRINT_ERR("ERROR SQL_TRANSACTION COMMIT: %d (%s)\n",
                        r, msg);
            else
            {
                if (log_upd_func)
                {
                    sqlite3_stmt * pStmt;
                    sqlite3_prepare_v2(pdb, "COMMIT TRANSACTION",
                                       -1, &pStmt, NULL);
                    log_upd_func(log_arg, pStmt);
                    sqlite3_finalize(pStmt);
                }
                ret = true;
            }
        }
        else
        {
            r = sqlite3_exec(pdb, "ROLLBACK TRANSACTION", NULL, NULL, &msg);
            if (r != SQLITE_OK)
                PRINT_ERR("ERROR SQL_TRANSACTION ROLLBACK: %d (%s)\n",
                        r, msg);
            else
            {
                if (log_upd_func)
                {
                    sqlite3_stmt * pStmt;
                    sqlite3_prepare_v2(pdb, "ROLLBACK TRANSACTION",
                                       -1, &pStmt, NULL);
                    log_upd_func(log_arg, pStmt);
                    sqlite3_finalize(pStmt);
                }
                ret = true;
            }
        }
        started = false;
    }

    if (msg)
        sqlite3_free(msg);

    return ret;
}

bool
SQL_TRANSACTION :: commit(void)
{
    return finish(/*commit*/true);
}

bool
SQL_TRANSACTION :: rollback(void)
{
    return finish(/*commit*/false);
}

}; // namespace library


/* source bottom line 1 */
/* source bottom line 2 */


