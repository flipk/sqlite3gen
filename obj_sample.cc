
///////////////////////////////////////////////////////////
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
//                                                       //
//       THIS FILE IS AUTOGENERATED BY sqlite3gen        //
// DO NOT EDIT THIS FILE, EDIT THE SOURCE AND REGENERATE //
//                                                       //
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
///////////////////////////////////////////////////////////

#include "sample.h"
#include <string.h>
#include <stdio.h>


SQL_TABLE_user :: SQL_TABLE_user(sqlite3 *_pdb, bool _debug)
    : pdb(_pdb), debug(_debug)
{
    int r;

    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;

    pStmt_by_userid = NULL;
    pStmt_by_ssn = NULL;

    pStmt_by_lastname_like = NULL;

    pStmt_get_great_balance = NULL;
    pStmt_get_founders = NULL;
    pStmt_get_firstlast = NULL;

    pStmt_update_balance = NULL;
    pStmt_update_firstlast = NULL;

    pStmt_del_ssn = NULL;


    previous_get = NULL;
}

SQL_TABLE_user :: ~SQL_TABLE_user(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);

    if (pStmt_by_userid)
        sqlite3_finalize(pStmt_by_userid);
    if (pStmt_by_ssn)
        sqlite3_finalize(pStmt_by_ssn);

    if (pStmt_by_lastname_like)
        sqlite3_finalize(pStmt_by_lastname_like);

    if (pStmt_get_great_balance)
        sqlite3_finalize(pStmt_get_great_balance);
    if (pStmt_get_founders)
        sqlite3_finalize(pStmt_get_founders);
    if (pStmt_get_firstlast)
        sqlite3_finalize(pStmt_get_firstlast);

    if (pStmt_update_balance)
        sqlite3_finalize(pStmt_update_balance);
    if (pStmt_update_firstlast)
        sqlite3_finalize(pStmt_update_firstlast);

    if (pStmt_del_ssn)
        sqlite3_finalize(pStmt_del_ssn);


}

bool SQL_TABLE_user :: get_columns(sqlite3_stmt * pStmt)
{
    int got, want;

    rowid = sqlite3_column_int64(pStmt, 0);

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        fprintf(stderr, "SQL_TABLE_user :: get_columns "
                "(userid) : "
                "column 1 wrong type (%d %d)\n",
                got, SQLITE_INTEGER);
        return false;
    }
    userid = sqlite3_column_int64(pStmt, 1);
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
        fprintf(stderr, "SQL_TABLE_user :: get_columns "
                "(firstname) : "
                "column 2 wrong type (%d %d)\n",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        firstname.resize(len);
        memcpy((void*)firstname.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_TEXT)
    {
        fprintf(stderr, "SQL_TABLE_user :: get_columns "
                "(lastname) : "
                "column 3 wrong type (%d %d)\n",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 3);
        int len = sqlite3_column_bytes(pStmt, 3);
        lastname.resize(len);
        memcpy((void*)lastname.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_TEXT)
    {
        fprintf(stderr, "SQL_TABLE_user :: get_columns "
                "(mi) : "
                "column 4 wrong type (%d %d)\n",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 4);
        int len = sqlite3_column_bytes(pStmt, 4);
        mi.resize(len);
        memcpy((void*)mi.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_INTEGER)
    {
        fprintf(stderr, "SQL_TABLE_user :: get_columns "
                "(ssn) : "
                "column 5 wrong type (%d %d)\n",
                got, SQLITE_INTEGER);
        return false;
    }
    ssn = sqlite3_column_int(pStmt, 5);
    got = sqlite3_column_type(pStmt, 6);
    if (got != SQLITE_FLOAT)
    {
        fprintf(stderr, "SQL_TABLE_user :: get_columns "
                "(balance) : "
                "column 6 wrong type (%d %d)\n",
                got, SQLITE_FLOAT);
        return false;
    }
    balance = sqlite3_column_double(pStmt, 6);
    got = sqlite3_column_type(pStmt, 7);
    if (got != SQLITE_BLOB)
    {
        fprintf(stderr, "SQL_TABLE_user :: get_columns "
                "(proto) : "
                "column 7 wrong type (%d %d)\n",
                got, SQLITE_BLOB);
        return false;
    }
    {
        const void * ptr = sqlite3_column_blob(
            pStmt, 7);
        int len = sqlite3_column_bytes(pStmt, 7);
        proto.resize(len);
        memcpy((void*)proto.c_str(), ptr, len);
    }


    return true;
}

bool SQL_TABLE_user :: get_by_userid(int64_t v)
{
    int r;
    bool ret = false;

    if (pStmt_by_userid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM user WHERE userid = ?",
            -1, &pStmt_by_userid, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for userid at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_userid);

    r = sqlite3_bind_int64(pStmt_by_userid, 1, v);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: get_by_userid "
                ": bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_by_userid);
        printf("SELECT get_by_userid: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_by_userid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_userid);
        previous_get = pStmt_by_userid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_ssn(int32_t v)
{
    int r;
    bool ret = false;

    if (pStmt_by_ssn == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM user WHERE ssn = ?",
            -1, &pStmt_by_ssn, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for ssn at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_ssn);

    r = sqlite3_bind_int(pStmt_by_ssn, 1, v);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: get_by_ssn "
                ": bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_by_ssn);
        printf("SELECT get_by_ssn: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_by_ssn);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_ssn);
        previous_get = pStmt_by_ssn;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: get_by_lastname_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if(pStmt_by_lastname_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM user WHERE lastname like ?",
            -1, &pStmt_by_lastname_like, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT LIKE for lastname at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_lastname_like);

    r = sqlite3_bind_text(pStmt_by_lastname_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: "
                "get_by_lastname_like : bind: r = %d\n", r);
        return false;
    }

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_by_lastname_like);
        printf("SELECT get_by_lastname_like: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_by_lastname_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_lastname_like);
        previous_get = pStmt_by_lastname_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


bool SQL_TABLE_user :: get_next(void)
{
    int r;
    bool ret = false;

    if (previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: insert(void)
{
    int r;

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO user "
            "(userid, firstname, lastname, mi, ssn, balance, proto) "
            "values (?,?,?,?,?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building INSERT at line %d\n", __LINE__);
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int64(pStmt_insert, 1, userid);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind userid: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind firstname: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 3,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind lastname: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 4,
         mi.c_str(), mi.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind mi: r = %d\n", r);
    }
    r = sqlite3_bind_int(pStmt_insert, 5, ssn);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind ssn: r = %d\n", r);
    }
    r = sqlite3_bind_double(pStmt_insert, 6, balance);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind balance: r = %d\n", r);
    }
    r = sqlite3_bind_blob(pStmt_insert, 7,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind proto: r = %d\n", r);
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_insert);
        printf("INSERT: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: r = %d\n", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_user :: update(void)
{
    int r;

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE user SET "
            "(userid, firstname, lastname, mi, ssn, balance, proto) "
            "= (?,?,?,?,?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building UPDATE at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int64(pStmt_insert, 1, userid);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind userid: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind firstname: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 3,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind lastname: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 4,
         mi.c_str(), mi.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind mi: r = %d\n", r);
    }
    r = sqlite3_bind_int(pStmt_insert, 5, ssn);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind ssn: r = %d\n", r);
    }
    r = sqlite3_bind_double(pStmt_insert, 6, balance);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind balance: r = %d\n", r);
    }
    r = sqlite3_bind_blob(pStmt_insert, 7,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: insert: "
                "bind proto: r = %d\n", r);
    }


    r = sqlite3_bind_int64(pStmt_update,
                           8, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_update);
        printf("UPDATE: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_user :: update: r = %d\n", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_user :: delete_rowid(void)
{
    int r;

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM user WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building UPDATE at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_delete_rowid);
        printf("DELETE: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_user :: "
                "delete_rowid: r = %d\n", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_user :: get_great_balance(double v1)
{
    int r;
    bool ret = false;

    if(pStmt_get_great_balance == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM user WHERE balance > ?",
            -1, &pStmt_get_great_balance, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for "
                   "CUSTOM-GET great_balance at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_get_great_balance);

    r = sqlite3_bind_double(pStmt_get_great_balance,
                             1, v1);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, 
                "SQL_TABLE_user :: get_great_balance "\
                ": bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_get_great_balance);
        printf("SELECT get_great_balance: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_get_great_balance);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_great_balance);
        previous_get = pStmt_get_great_balance;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_founders(void)
{
    int r;
    bool ret = false;

    if(pStmt_get_founders == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM user WHERE userid < 100",
            -1, &pStmt_get_founders, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for "
                   "CUSTOM-GET founders at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_get_founders);



    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_get_founders);
        printf("SELECT get_founders: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_get_founders);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_founders);
        previous_get = pStmt_get_founders;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_firstlast(const std::string & v1, const std::string & v2)
{
    int r;
    bool ret = false;

    if(pStmt_get_firstlast == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM user WHERE firstname LIKE ? AND lastname LIKE ?",
            -1, &pStmt_get_firstlast, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for "
                   "CUSTOM-GET firstlast at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_get_firstlast);

    r = sqlite3_bind_text(pStmt_get_firstlast, 1, 
                          v1.c_str(), v1.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, 
                "SQL_TABLE_user :: get_firstlast : "
                "bind: r = %d\n", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_get_firstlast, 2, 
                          v2.c_str(), v2.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, 
                "SQL_TABLE_user :: get_firstlast : "
                "bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_get_firstlast);
        printf("SELECT get_firstlast: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_get_firstlast);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_firstlast);
        previous_get = pStmt_get_firstlast;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: update_balance(void)
{
    int r;
    bool ret = false;

    if(pStmt_update_balance == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (balance) = "
            "(?) where rowid = ?",
            -1, &pStmt_update_balance, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building CUSTOM-UPD "
                   "balance at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update_balance);

    r = sqlite3_bind_double(pStmt_update_balance,
                             1, balance);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: "
                "update_balance: bind balance: r = %d\n", r);
    }


    r = sqlite3_bind_int64(pStmt_update_balance,
                           2, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_update_balance);
        printf("UPDATE update_balance: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_update_balance);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_user :: update "
                "balance: r = %d\n", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: update_firstlast(void)
{
    int r;
    bool ret = false;

    if(pStmt_update_firstlast == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (firstname, lastname) = "
            "(?,?) where rowid = ?",
            -1, &pStmt_update_firstlast, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building CUSTOM-UPD "
                   "firstlast at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update_firstlast);

    r = sqlite3_bind_text(pStmt_update_firstlast, 1, 
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: "
                "update_firstlast: bind firstname: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_update_firstlast, 2, 
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_user :: "
                "update_firstlast: bind lastname: r = %d\n", r);
    }


    r = sqlite3_bind_int64(pStmt_update_firstlast,
                           3, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_update_firstlast);
        printf("UPDATE update_firstlast: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_update_firstlast);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_user :: update "
                "firstlast: r = %d\n", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: delete_ssn(int32_t v1)
{
    int r;
    bool ret = false;

    if(pStmt_del_ssn == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "DELETE FROM user WHERE ssn = ?",
            -1, &pStmt_del_ssn, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building DELETE for "
                   "CUSTOM-DEL ssn at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_del_ssn);

    r = sqlite3_bind_int(pStmt_del_ssn,
                             1, v1);
    if (r != SQLITE_OK)
    {
        fprintf(stderr,
                "SQL_TABLE_user :: delete_ssn "\
                ": bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_del_ssn);
        printf("DELETE delete_ssn: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_del_ssn);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_del_ssn);
        previous_get = pStmt_del_ssn;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


//static
bool SQL_TABLE_user :: table_create(sqlite3 *pdb)
{
    sqlite3_exec(pdb, "CREATE TABLE user "
        "(userid int64, firstname string, lastname string, mi string, ssn integer, balance double, proto blob)",
        NULL, NULL, NULL);

    sqlite3_exec(pdb,"CREATE INDEX user_userid "
                 "ON user (userid)",
        NULL, NULL, NULL);
    sqlite3_exec(pdb,"CREATE INDEX user_ssn "
                 "ON user (ssn)",
        NULL, NULL, NULL);


    return true;
}

SQL_TABLE_book :: SQL_TABLE_book(sqlite3 *_pdb, bool _debug)
    : pdb(_pdb), debug(_debug)
{
    int r;

    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;

    pStmt_by_bookid = NULL;
    pStmt_by_isbn = NULL;

    pStmt_by_title_like = NULL;

    pStmt_get_out_of_stock = NULL;

    pStmt_update_quantity = NULL;
    pStmt_update_price = NULL;



    previous_get = NULL;
}

SQL_TABLE_book :: ~SQL_TABLE_book(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);

    if (pStmt_by_bookid)
        sqlite3_finalize(pStmt_by_bookid);
    if (pStmt_by_isbn)
        sqlite3_finalize(pStmt_by_isbn);

    if (pStmt_by_title_like)
        sqlite3_finalize(pStmt_by_title_like);

    if (pStmt_get_out_of_stock)
        sqlite3_finalize(pStmt_get_out_of_stock);

    if (pStmt_update_quantity)
        sqlite3_finalize(pStmt_update_quantity);
    if (pStmt_update_price)
        sqlite3_finalize(pStmt_update_price);



}

bool SQL_TABLE_book :: get_columns(sqlite3_stmt * pStmt)
{
    int got, want;

    rowid = sqlite3_column_int64(pStmt, 0);

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        fprintf(stderr, "SQL_TABLE_book :: get_columns "
                "(bookid) : "
                "column 1 wrong type (%d %d)\n",
                got, SQLITE_INTEGER);
        return false;
    }
    bookid = sqlite3_column_int64(pStmt, 1);
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
        fprintf(stderr, "SQL_TABLE_book :: get_columns "
                "(title) : "
                "column 2 wrong type (%d %d)\n",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        title.resize(len);
        memcpy((void*)title.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_TEXT)
    {
        fprintf(stderr, "SQL_TABLE_book :: get_columns "
                "(isbn) : "
                "column 3 wrong type (%d %d)\n",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 3);
        int len = sqlite3_column_bytes(pStmt, 3);
        isbn.resize(len);
        memcpy((void*)isbn.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_FLOAT)
    {
        fprintf(stderr, "SQL_TABLE_book :: get_columns "
                "(price) : "
                "column 4 wrong type (%d %d)\n",
                got, SQLITE_FLOAT);
        return false;
    }
    price = sqlite3_column_double(pStmt, 4);
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_INTEGER)
    {
        fprintf(stderr, "SQL_TABLE_book :: get_columns "
                "(quantity) : "
                "column 5 wrong type (%d %d)\n",
                got, SQLITE_INTEGER);
        return false;
    }
    quantity = sqlite3_column_int(pStmt, 5);


    return true;
}

bool SQL_TABLE_book :: get_by_bookid(int64_t v)
{
    int r;
    bool ret = false;

    if (pStmt_by_bookid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM book WHERE bookid = ?",
            -1, &pStmt_by_bookid, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for bookid at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_bookid);

    r = sqlite3_bind_int64(pStmt_by_bookid, 1, v);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: get_by_bookid "
                ": bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_by_bookid);
        printf("SELECT get_by_bookid: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_by_bookid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_bookid);
        previous_get = pStmt_by_bookid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_book :: get_by_isbn(const std::string & v)
{
    int r;
    bool ret = false;

    if (pStmt_by_isbn == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM book WHERE isbn = ?",
            -1, &pStmt_by_isbn, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for isbn at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_isbn);

    r = sqlite3_bind_text(pStmt_by_isbn, 1,
         v.c_str(), v.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: get_by_isbn "
                ": bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_by_isbn);
        printf("SELECT get_by_isbn: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_by_isbn);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_isbn);
        previous_get = pStmt_by_isbn;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: get_by_title_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if(pStmt_by_title_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM book WHERE title like ?",
            -1, &pStmt_by_title_like, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT LIKE for title at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_title_like);

    r = sqlite3_bind_text(pStmt_by_title_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: "
                "get_by_title_like : bind: r = %d\n", r);
        return false;
    }

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_by_title_like);
        printf("SELECT get_by_title_like: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_by_title_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_title_like);
        previous_get = pStmt_by_title_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


bool SQL_TABLE_book :: get_next(void)
{
    int r;
    bool ret = false;

    if (previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: insert(void)
{
    int r;

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO book "
            "(bookid, title, isbn, price, quantity) "
            "values (?,?,?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building INSERT at line %d\n", __LINE__);
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int64(pStmt_insert, 1, bookid);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind bookid: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         title.c_str(), title.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind title: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 3,
         isbn.c_str(), isbn.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind isbn: r = %d\n", r);
    }
    r = sqlite3_bind_double(pStmt_insert, 4, price);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind price: r = %d\n", r);
    }
    r = sqlite3_bind_int(pStmt_insert, 5, quantity);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind quantity: r = %d\n", r);
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_insert);
        printf("INSERT: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: r = %d\n", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_book :: update(void)
{
    int r;

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE book SET "
            "(bookid, title, isbn, price, quantity) "
            "= (?,?,?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building UPDATE at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int64(pStmt_insert, 1, bookid);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind bookid: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         title.c_str(), title.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind title: r = %d\n", r);
    }
    r = sqlite3_bind_text(pStmt_insert, 3,
         isbn.c_str(), isbn.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind isbn: r = %d\n", r);
    }
    r = sqlite3_bind_double(pStmt_insert, 4, price);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind price: r = %d\n", r);
    }
    r = sqlite3_bind_int(pStmt_insert, 5, quantity);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: insert: "
                "bind quantity: r = %d\n", r);
    }


    r = sqlite3_bind_int64(pStmt_update,
                           6, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_update);
        printf("UPDATE: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_book :: update: r = %d\n", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_book :: delete_rowid(void)
{
    int r;

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM book WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building UPDATE at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_delete_rowid);
        printf("DELETE: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_book :: "
                "delete_rowid: r = %d\n", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_book :: get_out_of_stock(void)
{
    int r;
    bool ret = false;

    if(pStmt_get_out_of_stock == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM book WHERE WHERE quantity == 0",
            -1, &pStmt_get_out_of_stock, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for "
                   "CUSTOM-GET out_of_stock at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_get_out_of_stock);



    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_get_out_of_stock);
        printf("SELECT get_out_of_stock: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_get_out_of_stock);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_out_of_stock);
        previous_get = pStmt_get_out_of_stock;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: update_quantity(void)
{
    int r;
    bool ret = false;

    if(pStmt_update_quantity == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE book SET (quantity) = "
            "(?) where rowid = ?",
            -1, &pStmt_update_quantity, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building CUSTOM-UPD "
                   "quantity at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update_quantity);

    r = sqlite3_bind_int(pStmt_update_quantity,
                             1, quantity);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: "
                "update_quantity: bind quantity: r = %d\n", r);
    }


    r = sqlite3_bind_int64(pStmt_update_quantity,
                           2, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_update_quantity);
        printf("UPDATE update_quantity: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_update_quantity);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_book :: update "
                "quantity: r = %d\n", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
bool SQL_TABLE_book :: update_price(void)
{
    int r;
    bool ret = false;

    if(pStmt_update_price == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE book SET (price) = "
            "(?) where rowid = ?",
            -1, &pStmt_update_price, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building CUSTOM-UPD "
                   "price at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update_price);

    r = sqlite3_bind_double(pStmt_update_price,
                             1, price);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_book :: "
                "update_price: bind price: r = %d\n", r);
    }


    r = sqlite3_bind_int64(pStmt_update_price,
                           2, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_update_price);
        printf("UPDATE update_price: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_update_price);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_book :: update "
                "price: r = %d\n", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}



//static
bool SQL_TABLE_book :: table_create(sqlite3 *pdb)
{
    sqlite3_exec(pdb, "CREATE TABLE book "
        "(userid int64, firstname string, lastname string, mi string, ssn integer, balance double, proto blob)",
        NULL, NULL, NULL);

    sqlite3_exec(pdb,"CREATE INDEX book_bookid "
                 "ON book (bookid)",
        NULL, NULL, NULL);
    sqlite3_exec(pdb,"CREATE INDEX book_isbn "
                 "ON book (isbn)",
        NULL, NULL, NULL);


    return true;
}

SQL_TABLE_checkouts :: SQL_TABLE_checkouts(sqlite3 *_pdb, bool _debug)
    : pdb(_pdb), debug(_debug)
{
    int r;

    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;

    pStmt_by_bookid = NULL;
    pStmt_by_userid = NULL;


    pStmt_get_due_now = NULL;




    previous_get = NULL;
}

SQL_TABLE_checkouts :: ~SQL_TABLE_checkouts(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);

    if (pStmt_by_bookid)
        sqlite3_finalize(pStmt_by_bookid);
    if (pStmt_by_userid)
        sqlite3_finalize(pStmt_by_userid);


    if (pStmt_get_due_now)
        sqlite3_finalize(pStmt_get_due_now);




}

bool SQL_TABLE_checkouts :: get_columns(sqlite3_stmt * pStmt)
{
    int got, want;

    rowid = sqlite3_column_int64(pStmt, 0);

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: get_columns "
                "(bookid) : "
                "column 1 wrong type (%d %d)\n",
                got, SQLITE_INTEGER);
        return false;
    }
    bookid = sqlite3_column_int64(pStmt, 1);
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_INTEGER)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: get_columns "
                "(userid) : "
                "column 2 wrong type (%d %d)\n",
                got, SQLITE_INTEGER);
        return false;
    }
    userid = sqlite3_column_int64(pStmt, 2);
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_INTEGER)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: get_columns "
                "(duedate) : "
                "column 3 wrong type (%d %d)\n",
                got, SQLITE_INTEGER);
        return false;
    }
    duedate = sqlite3_column_int64(pStmt, 3);


    return true;
}

bool SQL_TABLE_checkouts :: get_by_bookid(int64_t v)
{
    int r;
    bool ret = false;

    if (pStmt_by_bookid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM checkouts WHERE bookid = ?",
            -1, &pStmt_by_bookid, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for bookid at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_bookid);

    r = sqlite3_bind_int64(pStmt_by_bookid, 1, v);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: get_by_bookid "
                ": bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_by_bookid);
        printf("SELECT get_by_bookid: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_by_bookid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_bookid);
        previous_get = pStmt_by_bookid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_checkouts :: get_by_userid(int64_t v)
{
    int r;
    bool ret = false;

    if (pStmt_by_userid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM checkouts WHERE userid = ?",
            -1, &pStmt_by_userid, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for userid at line %d\n",
                   __LINE__);
    }

    sqlite3_reset(pStmt_by_userid);

    r = sqlite3_bind_int64(pStmt_by_userid, 1, v);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: get_by_userid "
                ": bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_by_userid);
        printf("SELECT get_by_userid: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_by_userid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_userid);
        previous_get = pStmt_by_userid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}



bool SQL_TABLE_checkouts :: get_next(void)
{
    int r;
    bool ret = false;

    if (previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_checkouts :: insert(void)
{
    int r;

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO checkouts "
            "(bookid, userid, duedate) "
            "values (?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building INSERT at line %d\n", __LINE__);
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int64(pStmt_insert, 1, bookid);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: insert: "
                "bind bookid: r = %d\n", r);
    }
    r = sqlite3_bind_int64(pStmt_insert, 2, userid);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: insert: "
                "bind userid: r = %d\n", r);
    }
    r = sqlite3_bind_int64(pStmt_insert, 3, duedate);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: insert: "
                "bind duedate: r = %d\n", r);
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_insert);
        printf("INSERT: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: insert: r = %d\n", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_checkouts :: update(void)
{
    int r;

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE checkouts SET "
            "(bookid, userid, duedate) "
            "= (?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building UPDATE at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int64(pStmt_insert, 1, bookid);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: insert: "
                "bind bookid: r = %d\n", r);
    }
    r = sqlite3_bind_int64(pStmt_insert, 2, userid);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: insert: "
                "bind userid: r = %d\n", r);
    }
    r = sqlite3_bind_int64(pStmt_insert, 3, duedate);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: insert: "
                "bind duedate: r = %d\n", r);
    }


    r = sqlite3_bind_int64(pStmt_update,
                           4, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_update);
        printf("UPDATE: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: update: r = %d\n", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_checkouts :: delete_rowid(void)
{
    int r;

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM checkouts WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building UPDATE at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_delete_rowid);
        printf("DELETE: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        fprintf(stderr, "SQL_TABLE_checkouts :: "
                "delete_rowid: r = %d\n", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_checkouts :: get_due_now(int64_t v1)
{
    int r;
    bool ret = false;

    if(pStmt_get_due_now == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,* FROM checkouts WHERE WHERE duedate > ?",
            -1, &pStmt_get_due_now, NULL);
        if (r != SQLITE_OK)
            printf("ERROR building SELECT for "
                   "CUSTOM-GET due_now at line %d\n", __LINE__);
    }

    sqlite3_reset(pStmt_get_due_now);

    r = sqlite3_bind_int64(pStmt_get_due_now,
                             1, v1);
    if (r != SQLITE_OK)
    {
        fprintf(stderr, 
                "SQL_TABLE_checkouts :: get_due_now "\
                ": bind: r = %d\n", r);
        return false;
    }


    if (debug)
    {
        char * sql = sqlite3_expanded_sql(pStmt_get_due_now);
        printf("SELECT get_due_now: %s\n", sql);
        sqlite3_free(sql);
    }

    r = sqlite3_step(pStmt_get_due_now);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_due_now);
        previous_get = pStmt_get_due_now;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}




//static
bool SQL_TABLE_checkouts :: table_create(sqlite3 *pdb)
{
    sqlite3_exec(pdb, "CREATE TABLE checkouts "
        "(userid int64, firstname string, lastname string, mi string, ssn integer, balance double, proto blob)",
        NULL, NULL, NULL);

    sqlite3_exec(pdb,"CREATE INDEX checkouts_bookid "
                 "ON checkouts (bookid)",
        NULL, NULL, NULL);
    sqlite3_exec(pdb,"CREATE INDEX checkouts_userid "
                 "ON checkouts (userid)",
        NULL, NULL, NULL);


    return true;
}

bool SQL_TABLE_ALL_TABLES :: table_create_all(sqlite3 *pdb)
{
    if (!SQL_TABLE_user::table_create(pdb))
        return false;
    if (!SQL_TABLE_book::table_create(pdb))
        return false;
    if (!SQL_TABLE_checkouts::table_create(pdb))
        return false;

    return true;
}
