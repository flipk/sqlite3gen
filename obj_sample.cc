
///////////////////////////////////////////////////////////
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
//                                                       //
//       THIS FILE IS AUTOGENERATED BY sqlite3gen        //
// DO NOT EDIT THIS FILE, EDIT THE SOURCE AND REGENERATE //
//                                                       //
// NOTE // NOTE // NOTE // NOTE // NOTE // NOTE // NOTE  //
///////////////////////////////////////////////////////////

#include "sample.h"
#include <string.h>
#include <stdio.h>
#include <sstream>


/* source top line 1 */
/* source top line 2 */


namespace library {

static void dflt_log_upd(void *arg, sqlite3_stmt *stmt)
{
    char * sql = sqlite3_expanded_sql(stmt);
    printf("SQL UPDATE: %s\n", sql);
    sqlite3_free(sql);
}

static void dflt_log_get(void *arg, sqlite3_stmt *stmt)
{
    char * sql = sqlite3_expanded_sql(stmt);
    printf("SQL GET: %s\n", sql);
    sqlite3_free(sql);
}

static void dflt_log_err(void *arg, const std::string &msg)
{
    printf("SQL ERROR: %s\n", msg.c_str());
}


//static
sql_log_function_t SQL_TABLE_user :: log_upd_func = &dflt_log_upd;
sql_log_function_t SQL_TABLE_user :: log_get_func = &dflt_log_get;
void *             SQL_TABLE_user :: log_arg  = NULL;
sql_err_function_t SQL_TABLE_user :: err_log_func = &dflt_log_err;
void *             SQL_TABLE_user :: err_log_arg  = NULL;

SQL_TABLE_user :: SQL_TABLE_user(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
}

void
SQL_TABLE_user :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

    pStmt_by_userid = NULL;
    pStmt_by_SSN = NULL;
    pStmt_by_test2 = NULL;
    pStmt_by_test3 = NULL;

    pStmt_by_lastname_like = NULL;

    pStmt_get_great_balance = NULL;
    pStmt_get_founders = NULL;
    pStmt_get_firstlast = NULL;

    pStmt_update_balance = NULL;
    pStmt_update_firstlast = NULL;
    pStmt_update_by_userid_stuff = NULL;

    pStmt_del_SSN = NULL;


    previous_get = NULL;
    init();
}

SQL_TABLE_user :: ~SQL_TABLE_user(void)
{
    finalize();
}

void
SQL_TABLE_user :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

    if (pStmt_by_userid)
        sqlite3_finalize(pStmt_by_userid);
    if (pStmt_by_SSN)
        sqlite3_finalize(pStmt_by_SSN);
    if (pStmt_by_test2)
        sqlite3_finalize(pStmt_by_test2);
    if (pStmt_by_test3)
        sqlite3_finalize(pStmt_by_test3);

    if (pStmt_by_lastname_like)
        sqlite3_finalize(pStmt_by_lastname_like);

    if (pStmt_get_great_balance)
        sqlite3_finalize(pStmt_get_great_balance);
    if (pStmt_get_founders)
        sqlite3_finalize(pStmt_get_founders);
    if (pStmt_get_firstlast)
        sqlite3_finalize(pStmt_get_firstlast);

    if (pStmt_update_balance)
        sqlite3_finalize(pStmt_update_balance);
    if (pStmt_update_firstlast)
        sqlite3_finalize(pStmt_update_firstlast);
    if (pStmt_update_by_userid_stuff)
        sqlite3_finalize(pStmt_update_by_userid_stuff);

    if (pStmt_del_SSN)
        sqlite3_finalize(pStmt_del_SSN);


    init_statements();
}

void SQL_TABLE_user :: init(void)
{
    rowid = -1;
    userid = -1;
    firstname = "";
    lastname = "";
    mi = "";
    SSN = 0;
    balance = 0;
    proto.clear();
    test2 = false;
    test3 = sample::library2::ENUM_TWO;

    previous_get = NULL;
}

//static
void
SQL_TABLE_user :: print_err(const char *function, int lineno,
                                     const char *format, ...)
{
    if (err_log_func == NULL)
        // don't bother formatting the args.
        return;

    std::ostringstream msg_out;
    msg_out << function << ":" << lineno << ": ";
    std::string msg = msg_out.str();

    size_t offset = msg.size();
    msg.resize(offset + 250);

    va_list ap;
    va_start(ap, format);
    size_t l = vsnprintf((char*)msg.c_str() + offset,
                         250, format, ap);
    va_end(ap);
    // note that *snprintf returns what it WOULD have written
    // if there was space! so l > msg.size means it truncated.
    if (l < 250)
        msg.resize(l + offset);
    err_log_func(err_log_arg, msg);
}

#undef  PRINT_ERR
#define PRINT_ERR(args...) print_err(__PRETTY_FUNCTION__, __LINE__, args)

bool SQL_TABLE_user :: get_columns(sqlite3_stmt * pStmt)
{
    int got;

    rowid = sqlite3_column_int64(pStmt, 0);

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (userid) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    userid = sqlite3_column_int64(pStmt, 1);
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (firstname) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        firstname.resize(len);
        memcpy((void*)firstname.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (lastname) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 3);
        int len = sqlite3_column_bytes(pStmt, 3);
        lastname.resize(len);
        memcpy((void*)lastname.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (mi) : "
                "column 4 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 4);
        int len = sqlite3_column_bytes(pStmt, 4);
        mi.resize(len);
        memcpy((void*)mi.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (SSN) : "
                "column 5 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    SSN = sqlite3_column_int(pStmt, 5);
    got = sqlite3_column_type(pStmt, 6);
    if (got != SQLITE_FLOAT)
    {
        PRINT_ERR("get_columns (balance) : "
                "column 6 wrong type (%d %d)",
                got, SQLITE_FLOAT);
        return false;
    }
    balance = sqlite3_column_double(pStmt, 6);
    got = sqlite3_column_type(pStmt, 7);
    if (got != SQLITE_BLOB)
    {
        PRINT_ERR("get_columns (proto) : "
                "column 7 wrong type (%d %d)",
                got, SQLITE_BLOB);
        return false;
    }
    {
        const void * ptr = sqlite3_column_blob(
            pStmt, 7);
        int len = sqlite3_column_bytes(pStmt, 7);
        proto.resize(len);
        memcpy((void*)proto.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 8);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (test2) : "
                "column 8 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sqlite3_column_int(pStmt, 8))
        test2 = true;
    else
        test2 = false;
    got = sqlite3_column_type(pStmt, 9);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (test3) : "
                "column 9 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    if (sample::library2::EnumField_t_IsValid(test3))
        test3 = (sample::library2::EnumField_t) sqlite3_column_int(
            pStmt, 9);
    else
        test3 = sample::library2::ENUM_TWO;



    return true;
}

bool SQL_TABLE_user :: get_by_userid(int64_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_userid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE userid = ?",
            -1, &pStmt_by_userid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_userid);

    r = sqlite3_bind_int64(pStmt_by_userid, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_userid);

    r = sqlite3_step(pStmt_by_userid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_userid);
        previous_get = pStmt_by_userid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_SSN(int32_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_SSN == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE SSN = ?",
            -1, &pStmt_by_SSN, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_SSN);

    r = sqlite3_bind_int(pStmt_by_SSN, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_SSN);

    r = sqlite3_step(pStmt_by_SSN);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_SSN);
        previous_get = pStmt_by_SSN;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_test2(bool v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_test2 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE test2 = ?",
            -1, &pStmt_by_test2, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_test2);

    r = sqlite3_bind_int(pStmt_by_test2, 1,
                             v ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_test2);

    r = sqlite3_step(pStmt_by_test2);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_test2);
        previous_get = pStmt_by_test2;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_by_test3(sample::library2::EnumField_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_test3 == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE test3 = ?",
            -1, &pStmt_by_test3, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_test3);

    r = sqlite3_bind_int(pStmt_by_test3, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_test3);

    r = sqlite3_step(pStmt_by_test3);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_test3);
        previous_get = pStmt_by_test3;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: get_by_lastname_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_by_lastname_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE lastname like ?",
            -1, &pStmt_by_lastname_like, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT LIKE for lastname", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_lastname_like);

    r = sqlite3_bind_text(pStmt_by_lastname_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_lastname_like);

    r = sqlite3_step(pStmt_by_lastname_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_lastname_like);
        previous_get = pStmt_by_lastname_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


bool SQL_TABLE_user :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO user "
            "(userid, firstname, lastname, mi, SSN, balance, proto, test2, test3) "
            "values (?,?,?,?,?,?,?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing INSERT", r);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int64(pStmt_insert, 1,
                             userid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind userid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind firstname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 3,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind lastname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 4,
         mi.c_str(), mi.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind mi: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 5,
                             SSN);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind SSN: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_insert, 6,
                             balance);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind balance: r = %d", r);
        return false;
    }
    r = sqlite3_bind_blob(pStmt_insert, 7,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind proto: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 8,
                             test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind test2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 9,
                             (int) test3);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind test3: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("insert: r = %d", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_user :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE user SET "
            "(userid, firstname, lastname, mi, SSN, balance, proto, test2, test3) "
            "= (?,?,?,?,?,?,?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing UPDATE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int64(pStmt_update, 1,
                             userid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind userid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 2,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind firstname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 3,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind lastname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 4,
         mi.c_str(), mi.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind mi: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 5,
                             SSN);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind SSN: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_update, 6,
                             balance);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind balance: r = %d", r);
        return false;
    }
    r = sqlite3_bind_blob(pStmt_update, 7,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind proto: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 8,
                             test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind test2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 9,
                             (int) test3);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind test3: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update,
                           10, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_user :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM user WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing DELETE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("delete: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_user :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_by_rowid", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_all", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: get_great_balance(double v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_great_balance == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE balance > ?",
            -1, &pStmt_get_great_balance, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET great_balance", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_great_balance);

    r = sqlite3_bind_double(pStmt_get_great_balance,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_great_balance);

    r = sqlite3_step(pStmt_get_great_balance);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_great_balance);
        previous_get = pStmt_get_great_balance;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_founders(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_founders == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE userid < 100",
            -1, &pStmt_get_founders, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET founders", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_founders);



    if (log_get_func)
        log_get_func(log_arg, pStmt_get_founders);

    r = sqlite3_step(pStmt_get_founders);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_founders);
        previous_get = pStmt_get_founders;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: get_firstlast(const std::string & v1, const std::string & v2)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_firstlast == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,userid, firstname, lastname, mi, SSN, balance, proto, test2, test3 FROM user "
            "WHERE firstname LIKE ? AND lastname LIKE ?",
            -1, &pStmt_get_firstlast, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET firstlast", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_firstlast);

    r = sqlite3_bind_text(pStmt_get_firstlast, 1, 
                          v1.c_str(), v1.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_get_firstlast, 2, 
                          v2.c_str(), v2.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_firstlast);

    r = sqlite3_step(pStmt_get_firstlast);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_firstlast);
        previous_get = pStmt_get_firstlast;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: update_balance(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_balance == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (balance) = "
            "(?) WHERE rowid = ?",
            -1, &pStmt_update_balance, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPD "
                   "balance", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_balance);

    r = sqlite3_bind_double(pStmt_update_balance,
                             1, balance);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind balance: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_balance,
                           2, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_balance);

    r = sqlite3_step(pStmt_update_balance);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update balance: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: update_firstlast(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_firstlast == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (firstname, lastname) = "
            "(?,?) WHERE rowid = ?",
            -1, &pStmt_update_firstlast, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPD "
                   "firstlast", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_firstlast);

    r = sqlite3_bind_text(
        pStmt_update_firstlast, 1,
         firstname.c_str(), firstname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind firstname: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(
        pStmt_update_firstlast, 2,
         lastname.c_str(), lastname.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind lastname: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_firstlast,
                           3, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_firstlast);

    r = sqlite3_step(pStmt_update_firstlast);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update firstlast: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
bool SQL_TABLE_user :: update_by_userid_stuff(int64_t v1, const std::string & v2)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_by_userid_stuff == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE user SET (proto, test2, test3, balance) = "
            "(?,?,?,?) WHERE userid = ? and lastname = ?",
            -1, &pStmt_update_by_userid_stuff, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPDBY "
                      "userid_stuff", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_by_userid_stuff);

    r = sqlite3_bind_blob(
        pStmt_update_by_userid_stuff, 1,
         proto.c_str(), proto.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind proto: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update_by_userid_stuff,
                             2, test2 ? 1 : 0);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind test2: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update_by_userid_stuff,
                             3, (int) test3);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind test3: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_update_by_userid_stuff,
                             4, balance);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind balance: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_update_by_userid_stuff,
                             5, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind field 1: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update_by_userid_stuff, 6,
                          v2.c_str(), v2.length(),
                          SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind field 2: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_by_userid_stuff);

    r = sqlite3_step(pStmt_update_by_userid_stuff);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update userid_stuff: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}

bool SQL_TABLE_user :: delete_SSN(int32_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if(pStmt_del_SSN == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "DELETE FROM user WHERE ssn = ?",
            -1, &pStmt_del_SSN, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-DEL", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_del_SSN);

    r = sqlite3_bind_int(pStmt_del_SSN,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind arg 1: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_del_SSN);

    r = sqlite3_step(pStmt_del_SSN);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_del_SSN);
        previous_get = pStmt_del_SSN;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

void
SQL_TABLE_user :: CopyToProto(
              library::TABLE_user_m &msg)
{
    msg.set_userid(userid);
    msg.set_firstname(firstname);
    msg.set_lastname(lastname);
    msg.set_mi(mi);
    msg.set_ssn(SSN);
    msg.set_balance(balance);
    msg.set_proto(proto);
    msg.set_test2(test2 ? true : false);
    if (!sample::library2::EnumField_t_IsValid(test3))
        test3 = sample::library2::ENUM_TWO;

    msg.set_test3(test3);

}

void
SQL_TABLE_user :: CopyFromProto(
              const library::TABLE_user_m &msg)
{
    if (msg.has_userid())
        userid = msg.userid();
    else
        userid = -1;

    if (msg.has_firstname())
        firstname = msg.firstname();
    else
        firstname = "";

    if (msg.has_lastname())
        lastname = msg.lastname();
    else
        lastname = "";

    if (msg.has_mi())
        mi = msg.mi();
    else
        mi = "";

    if (msg.has_ssn())
        SSN = msg.ssn();
    else
        SSN = 0;

    if (msg.has_balance())
        balance = msg.balance();
    else
        balance = 0;

    if (msg.has_proto())
        proto = msg.proto();
    else
        proto.clear();

    if (msg.has_test2())
        test2 = msg.test2() ? true : false;
    else
        test2 = false;

    if (msg.has_test3())
        test3 = msg.test3();
    else
        test3 = sample::library2::ENUM_TWO;


}


//static
bool SQL_TABLE_user :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"user\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("select from tables: %d", r);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"user\",19)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "user", v, 19);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (19) "
            "WHERE name = \"user\"",
            NULL, NULL, NULL);
    }
    else
    {
        PRINT_ERR("select from tables / step r = %d", r);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_user :: table_create(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    sqlite3_exec(pdb, "CREATE TABLE user "
        "(userid int64 NOT NULL UNIQUE, firstname string NOT NULL, lastname string NOT NULL, mi string, SSN integer NOT NULL UNIQUE, balance double, proto blob, test2 integer, test3 integer)",
        NULL, NULL, NULL);

    printf("CREATE TABLE: CREATE TABLE user "
           "(userid int64 NOT NULL UNIQUE, firstname string NOT NULL, lastname string NOT NULL, mi string, SSN integer NOT NULL UNIQUE, balance double, proto blob, test2 integer, test3 integer)\n");

    sqlite3_exec(pdb,"CREATE INDEX user_userid "
                 "ON user (userid)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX user_userid "
           "ON user (userid)\n");
    sqlite3_exec(pdb,"CREATE INDEX user_SSN "
                 "ON user (SSN)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX user_SSN "
           "ON user (SSN)\n");


    return true;
}

//static
void SQL_TABLE_user :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE user",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE user\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}


//static
sql_log_function_t SQL_TABLE_book :: log_upd_func = &dflt_log_upd;
sql_log_function_t SQL_TABLE_book :: log_get_func = &dflt_log_get;
void *             SQL_TABLE_book :: log_arg  = NULL;
sql_err_function_t SQL_TABLE_book :: err_log_func = &dflt_log_err;
void *             SQL_TABLE_book :: err_log_arg  = NULL;

SQL_TABLE_book :: SQL_TABLE_book(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
}

void
SQL_TABLE_book :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

    pStmt_by_bookid = NULL;
    pStmt_by_isbn = NULL;

    pStmt_by_title_like = NULL;

    pStmt_get_out_of_stock = NULL;

    pStmt_update_quantity = NULL;
    pStmt_update_price = NULL;



    previous_get = NULL;
    init();
}

SQL_TABLE_book :: ~SQL_TABLE_book(void)
{
    finalize();
}

void
SQL_TABLE_book :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

    if (pStmt_by_bookid)
        sqlite3_finalize(pStmt_by_bookid);
    if (pStmt_by_isbn)
        sqlite3_finalize(pStmt_by_isbn);

    if (pStmt_by_title_like)
        sqlite3_finalize(pStmt_by_title_like);

    if (pStmt_get_out_of_stock)
        sqlite3_finalize(pStmt_get_out_of_stock);

    if (pStmt_update_quantity)
        sqlite3_finalize(pStmt_update_quantity);
    if (pStmt_update_price)
        sqlite3_finalize(pStmt_update_price);



    init_statements();
}

void SQL_TABLE_book :: init(void)
{
    rowid = -1;
    bookid = 0;
    title = "";
    isbn = "";
    price = 0;
    quantity = 0;

    previous_get = NULL;
}

//static
void
SQL_TABLE_book :: print_err(const char *function, int lineno,
                                     const char *format, ...)
{
    if (err_log_func == NULL)
        // don't bother formatting the args.
        return;

    std::ostringstream msg_out;
    msg_out << function << ":" << lineno << ": ";
    std::string msg = msg_out.str();

    size_t offset = msg.size();
    msg.resize(offset + 250);

    va_list ap;
    va_start(ap, format);
    size_t l = vsnprintf((char*)msg.c_str() + offset,
                         250, format, ap);
    va_end(ap);
    // note that *snprintf returns what it WOULD have written
    // if there was space! so l > msg.size means it truncated.
    if (l < 250)
        msg.resize(l + offset);
    err_log_func(err_log_arg, msg);
}

#undef  PRINT_ERR
#define PRINT_ERR(args...) print_err(__PRETTY_FUNCTION__, __LINE__, args)

bool SQL_TABLE_book :: get_columns(sqlite3_stmt * pStmt)
{
    int got;

    rowid = sqlite3_column_int64(pStmt, 0);

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (bookid) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    bookid = sqlite3_column_int64(pStmt, 1);
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (title) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 2);
        int len = sqlite3_column_bytes(pStmt, 2);
        title.resize(len);
        memcpy((void*)title.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_TEXT)
    {
        PRINT_ERR("get_columns (isbn) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_TEXT);
        return false;
    }
    {
        const void * ptr = sqlite3_column_text(
            pStmt, 3);
        int len = sqlite3_column_bytes(pStmt, 3);
        isbn.resize(len);
        memcpy((void*)isbn.c_str(), ptr, len);
    }
    got = sqlite3_column_type(pStmt, 4);
    if (got != SQLITE_FLOAT)
    {
        PRINT_ERR("get_columns (price) : "
                "column 4 wrong type (%d %d)",
                got, SQLITE_FLOAT);
        return false;
    }
    price = sqlite3_column_double(pStmt, 4);
    got = sqlite3_column_type(pStmt, 5);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (quantity) : "
                "column 5 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    quantity = sqlite3_column_int(pStmt, 5);


    return true;
}

bool SQL_TABLE_book :: get_by_bookid(int64_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_bookid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book WHERE bookid = ?",
            -1, &pStmt_by_bookid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_bookid);

    r = sqlite3_bind_int64(pStmt_by_bookid, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_bookid);

    r = sqlite3_step(pStmt_by_bookid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_bookid);
        previous_get = pStmt_by_bookid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_book :: get_by_isbn(const std::string & v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_isbn == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book WHERE isbn = ?",
            -1, &pStmt_by_isbn, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_isbn);

    r = sqlite3_bind_text(pStmt_by_isbn, 1,
         v.c_str(), v.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_isbn);

    r = sqlite3_step(pStmt_by_isbn);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_isbn);
        previous_get = pStmt_by_isbn;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: get_by_title_like(
    const std::string &patt)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_by_title_like == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book "
            "WHERE title like ?",
            -1, &pStmt_by_title_like, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT LIKE for title", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_title_like);

    r = sqlite3_bind_text(pStmt_by_title_like, 1,
         patt.c_str(), patt.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_by_title_like);

    r = sqlite3_step(pStmt_by_title_like);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_title_like);
        previous_get = pStmt_by_title_like;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}


bool SQL_TABLE_book :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO book "
            "(bookid, title, isbn, price, quantity) "
            "values (?,?,?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing INSERT", r);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int64(pStmt_insert, 1,
                             bookid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind bookid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 2,
         title.c_str(), title.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind title: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_insert, 3,
         isbn.c_str(), isbn.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind isbn: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_insert, 4,
                             price);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind price: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_insert, 5,
                             quantity);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind quantity: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("insert: r = %d", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_book :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE book SET "
            "(bookid, title, isbn, price, quantity) "
            "= (?,?,?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing UPDATE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int64(pStmt_update, 1,
                             bookid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind bookid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 2,
         title.c_str(), title.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind title: r = %d", r);
        return false;
    }
    r = sqlite3_bind_text(pStmt_update, 3,
         isbn.c_str(), isbn.length(),
         SQLITE_STATIC);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind isbn: r = %d", r);
        return false;
    }
    r = sqlite3_bind_double(pStmt_update, 4,
                             price);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind price: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int(pStmt_update, 5,
                             quantity);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind quantity: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update,
                           6, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_book :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM book WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing DELETE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("delete: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_book :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_by_rowid", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_all", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: get_out_of_stock(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_out_of_stock == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, title, isbn, price, quantity FROM book "
            "WHERE quantity == 0",
            -1, &pStmt_get_out_of_stock, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET out_of_stock", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_out_of_stock);



    if (log_get_func)
        log_get_func(log_arg, pStmt_get_out_of_stock);

    r = sqlite3_step(pStmt_get_out_of_stock);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_out_of_stock);
        previous_get = pStmt_get_out_of_stock;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_book :: update_quantity(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_quantity == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE book SET (quantity) = "
            "(?) WHERE rowid = ?",
            -1, &pStmt_update_quantity, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPD "
                   "quantity", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_quantity);

    r = sqlite3_bind_int(pStmt_update_quantity,
                             1, quantity);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind quantity: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_quantity,
                           2, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_quantity);

    r = sqlite3_step(pStmt_update_quantity);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update quantity: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}
bool SQL_TABLE_book :: update_price(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if(pStmt_update_price == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "UPDATE book SET (price) = "
            "(?) WHERE rowid = ?",
            -1, &pStmt_update_price, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing CUSTOM-UPD "
                   "price", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update_price);

    r = sqlite3_bind_double(pStmt_update_price,
                             1, price);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind price: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update_price,
                           2, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update_price);

    r = sqlite3_step(pStmt_update_price);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update price: r = %d", r);
        return false;
    }
    previous_get = NULL;

    return ret;
}




//static
bool SQL_TABLE_book :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"book\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("select from tables: %d", r);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"book\",1)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "book", v, 1);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (1) "
            "WHERE name = \"book\"",
            NULL, NULL, NULL);
    }
    else
    {
        PRINT_ERR("select from tables / step r = %d", r);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_book :: table_create(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    sqlite3_exec(pdb, "CREATE TABLE book "
        "(bookid int64 NOT NULL UNIQUE, title string NOT NULL, isbn string NOT NULL UNIQUE, price double, quantity integer)",
        NULL, NULL, NULL);

    printf("CREATE TABLE: CREATE TABLE book "
           "(bookid int64 NOT NULL UNIQUE, title string NOT NULL, isbn string NOT NULL UNIQUE, price double, quantity integer)\n");

    sqlite3_exec(pdb,"CREATE INDEX book_bookid "
                 "ON book (bookid)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX book_bookid "
           "ON book (bookid)\n");
    sqlite3_exec(pdb,"CREATE INDEX book_isbn "
                 "ON book (isbn)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX book_isbn "
           "ON book (isbn)\n");


    return true;
}

//static
void SQL_TABLE_book :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE book",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE book\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}


//static
sql_log_function_t SQL_TABLE_checkouts :: log_upd_func = &dflt_log_upd;
sql_log_function_t SQL_TABLE_checkouts :: log_get_func = &dflt_log_get;
void *             SQL_TABLE_checkouts :: log_arg  = NULL;
sql_err_function_t SQL_TABLE_checkouts :: err_log_func = &dflt_log_err;
void *             SQL_TABLE_checkouts :: err_log_arg  = NULL;

SQL_TABLE_checkouts :: SQL_TABLE_checkouts(sqlite3 *_pdb)
    : pdb(_pdb)
{
    init_statements();
}

void
SQL_TABLE_checkouts :: init_statements(void)
{
    pStmt_insert = NULL;
    pStmt_update = NULL;
    pStmt_delete_rowid = NULL;
    pStmt_get_by_rowid = NULL;
    pStmt_get_all = NULL;

    pStmt_by_bookid = NULL;
    pStmt_by_userid = NULL;


    pStmt_get_due_now = NULL;




    previous_get = NULL;
    init();
}

SQL_TABLE_checkouts :: ~SQL_TABLE_checkouts(void)
{
    finalize();
}

void
SQL_TABLE_checkouts :: finalize(void)
{
    if (pStmt_insert)
        sqlite3_finalize(pStmt_insert);
    if (pStmt_update)
        sqlite3_finalize(pStmt_update);
    if (pStmt_delete_rowid)
        sqlite3_finalize(pStmt_delete_rowid);
    if (pStmt_get_by_rowid)
        sqlite3_finalize(pStmt_get_by_rowid);
    if (pStmt_get_all)
        sqlite3_finalize(pStmt_get_all);

    if (pStmt_by_bookid)
        sqlite3_finalize(pStmt_by_bookid);
    if (pStmt_by_userid)
        sqlite3_finalize(pStmt_by_userid);


    if (pStmt_get_due_now)
        sqlite3_finalize(pStmt_get_due_now);




    init_statements();
}

void SQL_TABLE_checkouts :: init(void)
{
    rowid = -1;
    bookid = 0;
    userid = 0;
    duedate = 0;

    previous_get = NULL;
}

//static
void
SQL_TABLE_checkouts :: print_err(const char *function, int lineno,
                                     const char *format, ...)
{
    if (err_log_func == NULL)
        // don't bother formatting the args.
        return;

    std::ostringstream msg_out;
    msg_out << function << ":" << lineno << ": ";
    std::string msg = msg_out.str();

    size_t offset = msg.size();
    msg.resize(offset + 250);

    va_list ap;
    va_start(ap, format);
    size_t l = vsnprintf((char*)msg.c_str() + offset,
                         250, format, ap);
    va_end(ap);
    // note that *snprintf returns what it WOULD have written
    // if there was space! so l > msg.size means it truncated.
    if (l < 250)
        msg.resize(l + offset);
    err_log_func(err_log_arg, msg);
}

#undef  PRINT_ERR
#define PRINT_ERR(args...) print_err(__PRETTY_FUNCTION__, __LINE__, args)

bool SQL_TABLE_checkouts :: get_columns(sqlite3_stmt * pStmt)
{
    int got;

    rowid = sqlite3_column_int64(pStmt, 0);

    got = sqlite3_column_type(pStmt, 1);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (bookid) : "
                "column 1 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    bookid = sqlite3_column_int64(pStmt, 1);
    got = sqlite3_column_type(pStmt, 2);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (userid) : "
                "column 2 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    userid = sqlite3_column_int64(pStmt, 2);
    got = sqlite3_column_type(pStmt, 3);
    if (got != SQLITE_INTEGER)
    {
        PRINT_ERR("get_columns (duedate) : "
                "column 3 wrong type (%d %d)",
                got, SQLITE_INTEGER);
        return false;
    }
    duedate = sqlite3_column_int64(pStmt, 3);


    return true;
}

bool SQL_TABLE_checkouts :: get_by_bookid(int64_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_bookid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, userid, duedate FROM checkouts WHERE bookid = ?",
            -1, &pStmt_by_bookid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_bookid);

    r = sqlite3_bind_int64(pStmt_by_bookid, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_bookid);

    r = sqlite3_step(pStmt_by_bookid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_bookid);
        previous_get = pStmt_by_bookid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}
bool SQL_TABLE_checkouts :: get_by_userid(int64_t v)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if (pStmt_by_userid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, userid, duedate FROM checkouts WHERE userid = ?",
            -1, &pStmt_by_userid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_by_userid);

    r = sqlite3_bind_int64(pStmt_by_userid, 1, v);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_by_userid);

    r = sqlite3_step(pStmt_by_userid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_by_userid);
        previous_get = pStmt_by_userid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}



bool SQL_TABLE_checkouts :: get_next(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL || previous_get == NULL)
        return false;

    r = sqlite3_step(previous_get);
    if (r == SQLITE_ROW)
        ret = get_columns(previous_get);
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_checkouts :: insert(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted INSERT before set_db");
        return false;
    }

    if (pStmt_insert == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "INSERT INTO checkouts "
            "(bookid, userid, duedate) "
            "values (?,?,?)",
            -1, &pStmt_insert, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing INSERT", r);
            return false;
        }
    }
    sqlite3_reset(pStmt_insert);

    r = sqlite3_bind_int64(pStmt_insert, 1,
                             bookid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind bookid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_insert, 2,
                             userid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind userid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_insert, 3,
                             duedate);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("insert: bind duedate: r = %d", r);
        return false;
    }


    if (log_upd_func)
        log_upd_func(log_arg, pStmt_insert);

    r = sqlite3_step(pStmt_insert);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("insert: r = %d", r);
        return false;
    }

    rowid = sqlite3_last_insert_rowid(pdb);

    return true;
}

bool SQL_TABLE_checkouts :: update(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted UPDATE before set_db");
        return false;
    }

    if (pStmt_update == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "UPDATE checkouts SET "
            "(bookid, userid, duedate) "
            "= (?,?,?) WHERE rowid = ?",
            -1, &pStmt_update, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing UPDATE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_update);

    r = sqlite3_bind_int64(pStmt_update, 1,
                             bookid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind bookid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_update, 2,
                             userid);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind userid: r = %d", r);
        return false;
    }
    r = sqlite3_bind_int64(pStmt_update, 3,
                             duedate);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("update: bind duedate: r = %d", r);
        return false;
    }


    r = sqlite3_bind_int64(pStmt_update,
                           4, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_update);

    r = sqlite3_step(pStmt_update);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("update: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_checkouts :: delete_rowid(void)
{
    int r;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted DELETE before set_db");
        return false;
    }

    if (pStmt_delete_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb, "DELETE FROM checkouts WHERE rowid = ?",
            -1, &pStmt_delete_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing DELETE", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_delete_rowid);

    r = sqlite3_bind_int64(pStmt_delete_rowid,
                           1, rowid);

    if (log_upd_func)
        log_upd_func(log_arg, pStmt_delete_rowid);

    r = sqlite3_step(pStmt_delete_rowid);
    if (r != SQLITE_DONE)
    {
        PRINT_ERR("delete: r = %d", r);
        return false;
    }

    return true;
}

bool SQL_TABLE_checkouts :: get_by_rowid(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_by_rowid == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, userid, duedate FROM checkouts WHERE rowid = ?",
            -1, &pStmt_get_by_rowid, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_by_rowid", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_by_rowid);

    r = sqlite3_bind_int64(pStmt_get_by_rowid,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_by_rowid);

    r = sqlite3_step(pStmt_get_by_rowid);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_by_rowid);
        previous_get = pStmt_get_by_rowid;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_checkouts :: get_all(void)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_all == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, userid, duedate FROM checkouts",
            -1, &pStmt_get_all, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for get_all", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_all);

    if (log_get_func)
        log_get_func(log_arg, pStmt_get_all);

    r = sqlite3_step(pStmt_get_all);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_all);
        previous_get = pStmt_get_all;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}

bool SQL_TABLE_checkouts :: get_due_now(int64_t v1)
{
    int r;
    bool ret = false;

    if (pdb == NULL)
    {
        PRINT_ERR("attempted GET before set_db");
        return false;
    }

    if(pStmt_get_due_now == NULL)
    {
        r = sqlite3_prepare_v2(
            pdb,
            "SELECT rowid,bookid, userid, duedate FROM checkouts "
            "WHERE duedate < ?",
            -1, &pStmt_get_due_now, NULL);
        if (r != SQLITE_OK)
        {
            PRINT_ERR("ERROR %d preparing SELECT for "
                   "CUSTOM-GET due_now", r);
            return false;
        }
    }

    sqlite3_reset(pStmt_get_due_now);

    r = sqlite3_bind_int64(pStmt_get_due_now,
                             1, v1);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("bind: r = %d", r);
        return false;
    }


    if (log_get_func)
        log_get_func(log_arg, pStmt_get_due_now);

    r = sqlite3_step(pStmt_get_due_now);
    if (r == SQLITE_ROW)
    {
        ret = get_columns(pStmt_get_due_now);
        previous_get = pStmt_get_due_now;
    }
    else if (r == SQLITE_DONE)
        previous_get = NULL;

    return ret;
}





//static
bool SQL_TABLE_checkouts :: init(sqlite3 *pdb, table_version_callback cb)
{
    bool ret = true;
    sqlite3_stmt * s;
    int r = sqlite3_prepare_v2(pdb,
        "select version from tables where name = \"checkouts\"",
        -1, &s, NULL);
    if (r != SQLITE_OK)
    {
        PRINT_ERR("select from tables: %d", r);
        return false;
    }
    sqlite3_reset(s);
    r = sqlite3_step(s);

    if (r == SQLITE_DONE)
    {
        if (!table_create(pdb))
            ret = false;
        sqlite3_exec(
            pdb,
            "INSERT INTO tables (name,version) "
            "values (\"checkouts\",1)",
            NULL, NULL, NULL);
    }
    else if (r == SQLITE_ROW)
    {
        int v = sqlite3_column_int(s,0);
        cb(pdb, "checkouts", v, 1);
        sqlite3_exec(
            pdb,
            "UPDATE tables SET (version) = (1) "
            "WHERE name = \"checkouts\"",
            NULL, NULL, NULL);
    }
    else
    {
        PRINT_ERR("select from tables / step r = %d", r);
        ret = false;
    }
    sqlite3_finalize(s);
    return ret;
}

//static
bool SQL_TABLE_checkouts :: table_create(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted CREATE with null db");
        return false;
    }

    sqlite3_exec(pdb, "CREATE TABLE checkouts "
        "(bookid int64 NOT NULL UNIQUE, userid int64, duedate int64, FOREIGN KEY(userid) REFERENCES user(userid))",
        NULL, NULL, NULL);

    printf("CREATE TABLE: CREATE TABLE checkouts "
           "(bookid int64 NOT NULL UNIQUE, userid int64, duedate int64, FOREIGN KEY(userid) REFERENCES user(userid))\n");

    sqlite3_exec(pdb,"CREATE INDEX checkouts_bookid "
                 "ON checkouts (bookid)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX checkouts_bookid "
           "ON checkouts (bookid)\n");
    sqlite3_exec(pdb,"CREATE INDEX checkouts_userid "
                 "ON checkouts (userid)",
        NULL, NULL, NULL);
    printf("CREATE INDEX: CREATE INDEX checkouts_userid "
           "ON checkouts (userid)\n");


    return true;
}

//static
void SQL_TABLE_checkouts :: table_drop(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        PRINT_ERR("attempted DROP with null db");
        return;
    }

    char * errmsg = NULL;
    sqlite3_exec(pdb, "DROP TABLE checkouts",
         NULL, NULL, &errmsg);
    if (errmsg != NULL)
    {
        // if you get error 6 tables is locked, some prepared
        // statement is still in a SQLITE_ROW state.
        PRINT_ERR("DROP error: %s", errmsg);
        sqlite3_free(errmsg);
    }

    printf("DROP: DROP TABLE checkouts\n");

    sqlite3_exec(pdb, "delete from tables "
                 "where name = \"user\"",
                 NULL, NULL, NULL);
}


bool SQL_TABLE_ALL_TABLES :: init_all(sqlite3 *pdb, table_version_callback cb)
{
    sqlite3_stmt * s;
    sqlite3_prepare_v2(pdb,
        "select * from sqlite_master "
        "where name = \"tables\" and type = \"table\"",
        -1, &s, NULL);
    sqlite3_reset(s);
    int r = sqlite3_step(s);
    if (r == SQLITE_DONE)
    {
        // the table does NOT exist, create it
        sqlite3_exec(pdb,
                     "CREATE TABLE tables (name text, version int)",
                     NULL, NULL, NULL);
    }
    sqlite3_finalize(s);

    if (!SQL_TABLE_user::init(pdb, cb))
        return false;
    if (!SQL_TABLE_book::init(pdb, cb))
        return false;
    if (!SQL_TABLE_checkouts::init(pdb, cb))
        return false;


    return true;
}

void SQL_TABLE_ALL_TABLES :: table_drop_all(sqlite3 *pdb)
{
    if (pdb == NULL)
    {
        fprintf(stderr, "attempted DROP (all) with null db\n");
        return;
    }

    SQL_TABLE_user::table_drop(pdb);
    SQL_TABLE_book::table_drop(pdb);
    SQL_TABLE_checkouts::table_drop(pdb);


    sqlite3_exec(pdb,
                 "DROP TABLE tables",
                 NULL, NULL, NULL);
}

}; // namespace library


/* source bottom line 1 */
/* source bottom line 2 */


